<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Syn√§sthesie - Harmonische Intervalle</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { 
            margin: 0;
            padding: 0;
            background: rgb(0, 0, 0); 
            overflow: hidden; 
            font-family: system-ui, sans-serif;
            width: 100%;
            height: 100%;
        }
        #canvas { 
            display: block; 
            position: fixed;
            top: 0;
            left: 0;
            z-index: 0;
        }
        #aiOverlayCanvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
            pointer-events: none;
        }
        
        /* === LINKE SPALTE === */
        #ui {
            position: fixed;
            top: 8px;
            left: 8px;
            z-index: 100;
            width: 160px;
            font-size: 9px;
        }
        
        /* === RECHTE SPALTE === */
        #ui-right {
            position: fixed;
            top: 8px;
            right: 8px;
            z-index: 100;
            width: 140px;
            font-size: 9px;
            max-height: calc(100vh - 16px);
            overflow-y: auto;
        }
        
        /* === UNTERE LEISTE === */
        #ui-bottom {
            position: fixed;
            bottom: 8px;
            left: 8px;
            right: 156px;
            z-index: 100;
            display: flex;
            align-items: flex-end;
            gap: 6px;
            font-size: 9px;
        }
        
        #ui-bottom .panel {
            flex: 1;
            margin-bottom: 0;
            min-width: 0;
        }
        
        /* Scrollbar */
        #ui-right::-webkit-scrollbar { width: 3px; }
        #ui-right::-webkit-scrollbar-track { background: transparent; }
        #ui-right::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }
        
        /* === PANEL BASIS === */
        .panel {
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            border-radius: 4px;
            padding: 6px;
            margin-bottom: 4px;
        }
        
        .panel h3 {
            color: #fff;
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
            opacity: 0.5;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }
        
        .panel h3 .minimize-btn {
            font-size: 10px;
            opacity: 0.6;
            transition: transform 0.2s;
        }
        
        .panel h3:hover .minimize-btn {
            opacity: 1;
        }
        
        .panel.minimized h3 {
            margin-bottom: 0;
        }
        
        .panel.minimized h3 .minimize-btn {
            transform: rotate(-90deg);
        }
        
        .panel.minimized .panel-content {
            display: none;
        }
        
        .panel.minimized {
            padding: 4px 6px;
        }
        
        /* === FORM ELEMENTS === */
        select {
            width: 100%;
            padding: 4px;
            font-size: 9px;
            border: none;
            border-radius: 3px;
            background: #222;
            color: #fff;
            margin-bottom: 4px;
            cursor: pointer;
            -webkit-appearance: menulist;
            appearance: menulist;
        }
        select:focus { outline: 1px solid #444; }
        select option {
            background: #222;
            color: #fff;
        }
        
        #startBtn {
            width: 100%;
            padding: 5px 8px;
            font-size: 10px;
            background: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        #startBtn.active { background: #4f4; }
        
        /* === NOTEN BADGES === */
        #detectedNotes {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            min-height: 20px;
        }
        .note-badge {
            padding: 2px 5px;
            border-radius: 2px;
            font-weight: bold;
            font-size: 9px;
            color: #000;
        }
        
        /* === PERCUSSION === */
        #detectedPercussion {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            min-height: 18px;
            margin-top: 4px;
        }
        .perc-badge {
            padding: 3px 6px;
            border-radius: 3px;
            font-weight: bold;
            font-size: 8px;
            color: #666;
            background: #222;
            border: 1px solid #333;
            transition: all 0.05s ease-out;
        }
        .perc-badge.active {
            color: #fff;
            transform: scale(1.15);
        }
        .perc-badge.kick { border-color: #e74c3c; }
        .perc-badge.kick.active { 
            background: #e74c3c; 
            box-shadow: 0 0 12px #e74c3c, 0 0 24px #e74c3c;
        }
        .perc-badge.snare { border-color: #f39c12; }
        .perc-badge.snare.active { 
            background: #f39c12; 
            box-shadow: 0 0 12px #f39c12, 0 0 24px #f39c12;
        }
        .perc-badge.hihat-closed { border-color: #3498db; }
        .perc-badge.hihat-closed.active { 
            background: #3498db; 
            box-shadow: 0 0 12px #3498db, 0 0 24px #3498db;
        }
        .perc-badge.hihat-open { border-color: #9b59b6; }
        .perc-badge.hihat-open.active { 
            background: #9b59b6; 
            box-shadow: 0 0 12px #9b59b6, 0 0 24px #9b59b6;
        }
        .perc-badge.tom { border-color: #27ae60; }
        .perc-badge.tom.active { 
            background: #27ae60; 
            box-shadow: 0 0 12px #27ae60, 0 0 24px #27ae60;
        }
        .perc-badge.crash { border-color: #1abc9c; }
        .perc-badge.crash.active { 
            background: #1abc9c; 
            box-shadow: 0 0 12px #1abc9c, 0 0 24px #1abc9c;
        }
        
        /* === SPEECH === */
        #speechText {
            margin-top: 6px;
            padding: 6px;
            background: #111;
            border-radius: 3px;
            font-size: 10px;
            color: #fff;
            min-height: 40px;
            max-height: 80px;
            overflow-y: auto;
            line-height: 1.4;
            word-wrap: break-word;
        }
        #speechText:empty::before {
            content: 'Warte auf Sprache...';
            color: #666;
        }
        #speechText .interim {
            color: #888;
            font-style: italic;
        }
        #speechText .final {
            color: #4f4;
        }
        #speechIndicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
            margin-right: 4px;
            vertical-align: middle;
        }
        #speechIndicator.listening {
            background: #f44;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 4px #f44; }
            50% { opacity: 0.5; box-shadow: 0 0 8px #f44; }
        }
        
        /* === INTERVALL === */
        #intervalDisplay {
            font-size: 11px;
            font-weight: bold;
            color: #fff;
            text-align: center;
            padding: 2px;
        }
        
        /* === SCHEMA BUTTONS === */
        .schema-selector {
            display: flex;
            gap: 2px;
            margin-bottom: 4px;
        }
        .schema-btn {
            flex: 1;
            padding: 4px 2px;
            border: 1px solid #333;
            background: transparent;
            color: #fff;
            border-radius: 3px;
            cursor: pointer;
            font-size: 8px;
        }
        .schema-btn.active { border-color: #fff; background: rgba(255,255,255,0.1); }
        
        /* === CHECKBOXES === */
        .interaction-mode {
            margin-top: 3px;
            padding-top: 3px;
            border-top: 1px solid #222;
        }
        .interaction-mode label {
            display: flex;
            align-items: center;
            gap: 4px;
            color: #888;
            font-size: 8px;
            cursor: pointer;
        }
        .interaction-mode input {
            width: 10px;
            height: 10px;
        }
        
        /* === SLIDER === */
        .slider-group {
            margin-top: 3px;
        }
        .slider-group label {
            display: block;
            color: #666;
            font-size: 8px;
            margin-bottom: 1px;
        }
        .slider-row {
            display: flex;
            align-items: center;
            gap: 3px;
        }
        .slider-row input[type="range"] {
            flex: 1;
            height: 2px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 1px;
        }
        .slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 8px;
            height: 8px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }
        .slider-row span {
            color: #fff;
            font-size: 8px;
            min-width: 24px;
            text-align: right;
        }
        
        /* === EQ === */
        .eq-container { display: flex; flex-direction: column; gap: 3px; }
        .eq-band { display: flex; flex-direction: column; gap: 0; }
        .eq-band label {
            color: #666;
            font-size: 7px;
            display: flex;
            justify-content: space-between;
        }
        .eq-band input[type="range"] {
            width: 100%;
            height: 2px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 1px;
        }
        .eq-band input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 6px;
            height: 6px;
            background: #fff;
            border-radius: 50%;
        }
        
        /* === MASTER FADER === */
        .fader-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            padding: 2px 0;
        }
        .fader-track {
            position: relative;
            width: 30px;
            height: 60px;
            background: linear-gradient(to top, #222 0%, #333 50%, #222 100%);
            border-radius: 2px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .fader-track input[type="range"] {
            -webkit-appearance: none;
            width: 50px;
            height: 20px;
            background: transparent;
            cursor: pointer;
            transform: rotate(-90deg);
        }
        .fader-track input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 10px;
            background: linear-gradient(to bottom, #eee 0%, #999 100%);
            border-radius: 2px;
            border: 1px solid #666;
        }
        .fader-track input[type="range"]::-webkit-slider-runnable-track {
            height: 3px;
            background: #444;
            border-radius: 1px;
        }
        .fader-value {
            font-size: 10px;
            font-weight: bold;
            color: #fff;
            font-family: monospace;
        }
        .fader-label {
            font-size: 7px;
            color: #666;
            text-transform: uppercase;
        }
        .fader-db-marks {
            position: absolute;
            right: -14px;
            top: 0;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            font-size: 6px;
            color: #444;
            padding: 2px 0;
        }
        
        /* === LEVEL METER === */
        .level-meter {
            width: 100%;
            height: 4px;
            background: #222;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 3px;
        }
        .level-meter-fill {
            height: 100%;
            background: linear-gradient(to right, #4f4 0%, #ff0 60%, #f44 90%);
            transition: width 0.05s;
            width: 0%;
        }
        
        /* === AI IMAGE === */
        #aiImageContainer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 50;
            display: none;
            pointer-events: none;
        }
        #aiImageContainer.overlay-mode {
            display: block;
            opacity: 0.5;
            mix-blend-mode: screen;
        }
        #aiImageContainer.on-mode {
            display: block;
            opacity: 1;
            mix-blend-mode: normal;
        }
        #aiImage {
            max-width: 512px;
            max-height: 512px;
            border-radius: 8px;
        }
        #aiImageStatus {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            color: #888;
            white-space: nowrap;
        }
        .ai-mode-selector {
            display: flex;
            gap: 2px;
            margin-bottom: 4px;
        }
        .ai-mode-btn {
            flex: 1;
            padding: 4px 2px;
            border: 1px solid #333;
            background: transparent;
            color: #fff;
            border-radius: 3px;
            cursor: pointer;
            font-size: 8px;
        }
        .ai-mode-btn.active { border-color: #fff; background: rgba(255,255,255,0.1); }
        
        /* === AI MODEL TABS === */
        .ai-model-tabs {
            display: flex;
            gap: 2px;
            margin-top: 4px;
            flex-wrap: wrap;
        }
        .ai-model-tab {
            flex: 1;
            min-width: 40px;
            padding: 3px 2px;
            border: 1px solid #333;
            background: #1a1a1a;
            color: #888;
            border-radius: 3px;
            cursor: pointer;
            font-size: 7px;
            transition: all 0.2s;
        }
        .ai-model-tab:hover {
            border-color: #555;
            color: #fff;
        }
        .ai-model-tab.active {
            border-color: #4f4;
            background: rgba(68, 255, 68, 0.1);
            color: #4f4;
        }
        .ai-model-tab.has-images {
            border-color: #ff0;
        }
        .ai-model-tab.active.has-images {
            border-color: #4f4;
        }
        
        /* === PROVIDER TABS === */
        .ai-provider-tabs {
            display: flex;
            gap: 2px;
            margin-top: 4px;
        }
        .ai-provider-tab {
            flex: 1;
            padding: 4px 2px;
            border: 1px solid #333;
            background: #1a1a1a;
            color: #888;
            border-radius: 3px;
            cursor: pointer;
            font-size: 7px;
            transition: all 0.2s;
        }
        .ai-provider-tab:hover {
            border-color: #555;
            color: #fff;
        }
        .ai-provider-tab.active {
            border-color: #4af;
            background: rgba(68, 170, 255, 0.1);
            color: #4af;
        }
        .ai-provider-tab.has-key {
            border-color: #4f4;
        }
        .ai-provider-tab.active.has-key {
            border-color: #4f4;
            color: #4f4;
        }
        .ai-provider-tab.has-images {
            border-color: #ff0;
        }
        .ai-provider-tab.active.has-images {
            border-color: #ff0;
        }
        .key-warning {
            font-size: 7px;
            color: #f84;
            padding: 2px 4px;
            background: rgba(255, 136, 68, 0.1);
            border-radius: 2px;
            margin-top: 2px;
            text-align: center;
        }
        .key-warning.hidden {
            display: none;
        }
        .ai-model-group {
            margin-top: 2px;
        }
        
        /* === MODEL STATUS === */
        .model-status {
            padding: 1px 4px;
            background: #222;
            border-radius: 2px;
            border: 1px solid #333;
        }
        .model-status.active {
            border-color: #4f4;
            color: #4f4;
        }
        .model-status.has-images {
            color: #ff0;
        }
        
        #aiImagePreview {
            margin-top: 4px;
            height: 60px;
            background: #111;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        #aiImagePreview img {
            max-width: 100%;
            max-height: 60px;
            border-radius: 2px;
        }
        #aiImagePreview .placeholder {
            color: #444;
            font-size: 8px;
        }
        
        /* === AI GENERATION STATUS === */
        .ai-spinner {
            display: inline-block;
            width: 8px;
            height: 8px;
            border: 2px solid #444;
            border-top-color: #4f4;
            border-radius: 50%;
            animation: ai-spin 0.8s linear infinite;
            margin-right: 4px;
            vertical-align: middle;
        }
        @keyframes ai-spin {
            to { transform: rotate(360deg); }
        }
        #aiGenStatus {
            display: flex;
            align-items: center;
        }
        
        /* === AI BUFFER THUMBNAILS === */
        #aiBufferThumbs {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            margin-top: 4px;
            height: 86px;
            overflow-y: auto;
            background: #0a0a0a;
            border-radius: 3px;
            padding: 3px;
        }
        .ai-thumb {
            width: 36px;
            height: 36px;
            border-radius: 2px;
            object-fit: cover;
            cursor: pointer;
            opacity: 0.6;
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        .ai-thumb:hover {
            opacity: 1;
            transform: scale(1.1);
            z-index: 1;
        }
        .ai-thumb.active {
            opacity: 1;
            border-color: #4f4;
            box-shadow: 0 0 6px #4f4;
        }
        .ai-thumb.generating {
            opacity: 0.3;
            border-color: #ff0;
            animation: thumbPulse 1s infinite;
        }
        @keyframes thumbPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.6; }
        }
        .ai-thumb-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            background: #1a1a1a;
            border: 1px dashed #444;
            opacity: 1 !important;
        }
        .ai-thumb-loading .ai-spinner {
            width: 12px;
            height: 12px;
        }
        
        /* === BUTTONS === */
        .reset-btn {
            width: 100%;
            margin-top: 4px;
            padding: 3px;
            background: #333;
            color: #fff;
            border: none;
            border-radius: 2px;
            cursor: pointer;
            font-size: 8px;
        }
        
        /* === MODEL SET ROW === */
        .model-set-row {
            display: flex;
            gap: 3px;
            margin-bottom: 3px;
        }
        .model-set-row select {
            flex: 1;
            margin-bottom: 0;
        }
        .model-set-row button {
            padding: 4px 6px;
            background: #333;
            border: none;
            border-radius: 3px;
            color: #fff;
            cursor: pointer;
            font-size: 9px;
        }
        .model-set-row button:hover {
            background: #444;
        }
        .model-set-row button.scanning {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        /* === AI IMAGE === */
        #aiImageContainer {
            position: relative;
            width: 100%;
            aspect-ratio: 1;
            background: #111;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 4px;
        }
        #aiImageContainer.overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80vmin;
            height: 80vmin;
            z-index: 50;
            border-radius: 8px;
            box-shadow: 0 0 40px rgba(0,0,0,0.8);
        }
        #aiImage {
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        #aiImage.loaded {
            opacity: 1;
        }
        #aiImageStatus {
            position: absolute;
            bottom: 4px;
            left: 4px;
            right: 4px;
            font-size: 7px;
            color: #888;
            background: rgba(0,0,0,0.7);
            padding: 2px 4px;
            border-radius: 2px;
        }
        #aiImagePrompt {
            position: absolute;
            top: 4px;
            left: 4px;
            right: 4px;
            font-size: 7px;
            color: #aaa;
            background: rgba(0,0,0,0.7);
            padding: 2px 4px;
            border-radius: 2px;
            max-height: 40px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .ai-mode-selector {
            display: flex;
            gap: 2px;
            margin-bottom: 4px;
        }
        .ai-mode-btn {
            flex: 1;
            padding: 4px 2px;
            border: 1px solid #333;
            background: transparent;
            color: #fff;
            border-radius: 3px;
            cursor: pointer;
            font-size: 8px;
        }
        .ai-mode-btn.active {
            border-color: #fff;
            background: rgba(255,255,255,0.1);
        }
        #aiImageLoading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            font-size: 10px;
        }
        #aiImageLoading.active {
            color: #4af;
        }
        @keyframes aiPulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        #aiImageLoading.active {
            animation: aiPulse 1s ease-in-out infinite;
        }
        
        /* === ALGO GRID === */
        .algo-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2px;
        }
        .algo-btn {
            padding: 3px 2px;
            font-size: 7px;
            background: #222;
            color: #888;
            border: 1px solid #333;
            border-radius: 2px;
            cursor: pointer;
            text-align: center;
        }
        .algo-btn.active {
            background: #446;
            color: #fff;
            border-color: #668;
        }
        .algo-combine {
            margin-top: 3px;
            display: flex;
            align-items: center;
            gap: 2px;
        }
        .algo-combine label { font-size: 7px; color: #666; }
        .algo-combine select {
            flex: 1;
            padding: 2px;
            font-size: 7px;
            margin-bottom: 0;
        }
        .algo-description {
            margin-top: 3px;
            padding: 3px;
            background: #1a1a1a;
            border-radius: 2px;
            font-size: 6px;
            color: #666;
            line-height: 1.2;
        }
        
        /* === EFFECT GRID === */
        .effect-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2px;
        }
        .effect-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .effect-btn {
            padding: 4px 2px;
            font-size: 7px;
            background: #222;
            color: #888;
            border: 1px solid #333;
            border-radius: 2px;
            cursor: pointer;
            text-align: center;
        }
        .effect-btn.active {
            background: linear-gradient(135deg, #a044ff, #ff4488);
            color: #fff;
            border-color: #ff66aa;
        }
        .effect-slider {
            display: none;
            padding: 2px;
            background: rgba(160, 68, 255, 0.1);
            border-radius: 2px;
        }
        .effect-slider.visible {
            display: block;
        }
        .effect-slider input[type="range"] {
            width: 100%;
            height: 2px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 1px;
        }
        .effect-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 8px;
            height: 8px;
            background: #ff66aa;
            border-radius: 50%;
            cursor: pointer;
        }
        .effect-slider-value {
            font-size: 7px;
            color: #ff66aa;
            text-align: center;
        }
        
        /* === BEAT DISPLAY === */
        .beat-display {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 3px;
        }
        .bpm-value {
            font-size: 12px;
            font-weight: bold;
            color: #fff;
        }
        .beat-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #333;
            border: 2px solid #555;
        }
        .beat-indicator.flash {
            background: #ff6600;
            box-shadow: 0 0 8px #ff6600;
        }
        
        /* === FULLSCREEN TOGGLE === */
        #fullscreenToggle {
            position: fixed;
            top: 8px;
            right: 156px;
            z-index: 200;
            width: 24px;
            height: 24px;
            background: rgba(0,0,0,0.8);
            border: none;
            border-radius: 4px;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* === FULLSCREEN MODE === */
        body.fullscreen-mode #ui,
        body.fullscreen-mode #ui-right,
        body.fullscreen-mode #ui-bottom {
            opacity: 0;
            pointer-events: none;
        }
        body.fullscreen-mode #fullscreenToggle {
            right: 20px;
            opacity: 0.3;
        }
        body.fullscreen-mode #fullscreenToggle:hover { opacity: 1; }
        
        /* === VIGNETTE === */
        #vignetteOverlay {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            pointer-events: none;
            z-index: 1;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #vignetteOverlay.active { opacity: 1; }
        
        /* === STREAM STATUS === */
        #streamStatus {
            position: fixed;
            top: 8px;
            left: 176px;
            z-index: 100;
            padding: 4px 8px;
            background: rgba(0,0,0,0.8);
            border-radius: 4px;
            font-size: 9px;
            color: #666;
            display: none;
        }
        #streamStatus.active {
            display: block;
            color: #4f4;
        }
        #streamStatus.active::before {
            content: '‚óè ';
            color: #f44;
        }
        
        /* === DEBUG === */
        #debugInfo {
            font-family: monospace;
            font-size: 8px;
            color: #555;
            max-height: 50px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <!-- Fullscreen Toggle -->
    <button id="fullscreenToggle" title="Vollbild (F)">‚õ∂</button>
    
    <!-- Stream Status -->
    <div id="streamStatus">localhost:9876</div>
    
    <!-- Vignette Overlay f√ºr Alex -->
    <div id="vignetteOverlay"></div>
    
    <div id="ui">
        <!-- Audio Control -->
        <div class="panel">
            <h3>Audioquelle</h3>
            <select id="audioSourceSelect">
                <option value="">-- Ger√§t w√§hlen --</option>
            </select>
            <button id="startBtn">üé§ Starten</button>
        </div>
        
        <!-- Audio Output -->
        <div class="panel">
            <h3>Audioausgabe</h3>
            <select id="audioOutputSelect">
                <option value="">-- Ausgabe w√§hlen --</option>
            </select>
            <div class="interaction-mode">
                <label>
                    <input type="checkbox" id="audioPassthroughEnabled">
                    Audio durchschleifen
                </label>
            </div>
            <div class="slider-group" id="passthroughVolumeControl" style="opacity: 0.5;">
                <label>Lautst√§rke</label>
                <div class="slider-row">
                    <input type="range" id="passthroughVolume" min="0" max="100" value="80" disabled>
                    <span id="passthroughVolumeValue">80%</span>
                </div>
            </div>
        </div>
        
        <!-- MIDI Control -->
        <div class="panel">
            <h3>MIDI Controller</h3>
            <select id="midiDeviceSelect">
                <option value="">-- MIDI Ger√§t w√§hlen --</option>
            </select>
            <div class="interaction-mode">
                <label>
                    <input type="checkbox" id="midiEnabled">
                    MIDI als Eingabe nutzen
                </label>
            </div>
            <div class="interaction-mode">
                <label>
                    <input type="checkbox" id="midiSynthEnabled">
                    MIDI Sound abspielen
                </label>
            </div>
            <div class="slider-group" id="midiSynthVolumeControl" style="opacity: 0.5;">
                <label>Synth Lautst√§rke</label>
                <div class="slider-row">
                    <input type="range" id="midiSynthVolume" min="0" max="100" value="50" disabled>
                    <span id="midiSynthVolumeValue">50%</span>
                </div>
            </div>
            <div id="midiStatus" style="color:#666; font-size:11px; margin-top:8px;">MIDI nicht verbunden</div>
        </div>
        
        <!-- Erkannte T√∂ne -->
        <div class="panel">
            <h3>Erkannte T√∂ne</h3>
            <div id="detectedNotes">
                <span style="color:#666">Warte auf Audio...</span>
            </div>
            <div id="intervalDisplay" style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #333;">-</div>
        </div>
        
        <!-- Percussion -->
        <div class="panel">
            <h3>Percussion</h3>
            <div class="interaction-mode">
                <label>
                    <input type="checkbox" id="percussionEnabled">
                    Percussion erkennen
                </label>
            </div>
            <div id="detectedPercussion">
                <span style="color:#666">-</span>
            </div>
        </div>
        
        <!-- Speech Recognition -->
        <div class="panel">
            <h3>Sprache üåê</h3>
            <div class="interaction-mode">
                <label>
                    <input type="checkbox" id="speechEnabled">
                    Sprache erkennen
                </label>
            </div>
            <select id="speechLang" style="margin-top:4px;">
                <option value="de-DE">Deutsch</option>
                <option value="en-US">English (US)</option>
                <option value="en-GB">English (UK)</option>
                <option value="fr-FR">Fran√ßais</option>
                <option value="es-ES">Espa√±ol</option>
                <option value="it-IT">Italiano</option>
            </select>
            <div id="speechStatus" style="color:#888; font-size:9px; margin-top:6px; padding:4px; background:#111; border-radius:3px;">
                ‚è∏ Aus
            </div>
            <div style="font-size:7px; color:#555; margin-top:3px;">
                ‚ö† Nutzt System-Mikrofon
            </div>
            <div id="speechText"></div>
        </div>
        
        <!-- Debug -->
        <div class="panel">
            <h3>Debug</h3>
            <div id="debugInfo"></div>
        </div>
    </div>
    
    <!-- Unteres Panel: Farbschema, 3D Modell, Effekte -->
    <div id="ui-bottom">
        <!-- Farbschema -->
        <div class="panel" id="panelFarbschema">
            <h3><span>Farbschema</span><span class="minimize-btn">‚ñº</span></h3>
            <div class="panel-content">
            <div class="schema-selector">
                <button class="schema-btn active" data-schema="clara">Clara</button>
                <button class="schema-btn" data-schema="alex">Alex</button>
                <button class="schema-btn" data-schema="both">Beide</button>
            </div>
            
            <div class="interaction-mode">
                <label>
                    <input type="checkbox" id="blendSchemas">
                    Schemata mischen (Blend)
                </label>
            </div>
            
            <div class="interaction-mode">
                <label>
                    <input type="checkbox" id="alexDegreeColors">
                    Alex: Stufen-Farben (I-VII)
                </label>
            </div>
            
            <div class="interaction-mode">
                <label>
                    <input type="checkbox" id="alexGradient">
                    Alex: Farbverl√§ufe
                </label>
            </div>
            
            <div class="interaction-mode">
                <label>
                    <input type="checkbox" id="alexVignette">
                    Alex: Vignette
                </label>
            </div>
            
            <div class="slider-group" id="blendControl" style="display:none;">
                <label>Clara ‚Üî Alex</label>
                <div class="slider-row">
                    <input type="range" id="blendSlider" min="0" max="100" value="50">
                    <span id="blendValue">50%</span>
                </div>
            </div>
            </div>
        </div>
        
        <!-- Modell-Kontrolle -->
        <div class="panel" id="panel3DModell">
            <h3><span>3D Modell</span><span class="minimize-btn">‚ñº</span></h3>
            <div class="panel-content">
            <div class="interaction-mode" style="margin-top:0; padding-top:0; border-top:none;">
                <label>
                    <input type="checkbox" id="modelVisible" checked>
                    Modell anzeigen
                </label>
            </div>
            <div class="model-set-row">
                <select id="modelSetSelect">
                    <option value="">Standard (Legacy)</option>
                </select>
                <button id="scanModelSetsBtn" title="Nach Model-Sets scannen">üîÑ</button>
            </div>
            <div id="modelSetStatus" style="font-size: 7px; color: #666; margin-bottom: 3px;"></div>
            <div class="slider-group">
                <label>Skalierung</label>
                <div class="slider-row">
                    <input type="range" id="scaleSlider" min="0.1" max="5" step="0.1" value="1">
                    <span id="scaleValue">1.0</span>
                </div>
            </div>
            <div class="slider-group">
                <label>Sensitivit√§t</label>
                <div class="slider-row">
                    <input type="range" id="sensitivitySlider" min="0.01" max="0.2" step="0.01" value="0.05">
                    <span id="sensitivityValue">0.05</span>
                </div>
            </div>
            <div class="interaction-mode">
                <label>
                    <input type="checkbox" id="morphingEnabled" checked>
                    Morphing
                </label>
            </div>
            <div class="slider-group" id="morphDurationControl">
                <label>Morph-Dauer</label>
                <div class="slider-row">
                    <input type="range" id="morphDuration" min="100" max="1500" step="50" value="500">
                    <span id="morphDurationValue">500ms</span>
                </div>
            </div>
            </div>
        </div>
        
        <!-- Effekte -->
        <div class="panel" id="panelEffekte">
            <h3><span>Effekte</span><span class="minimize-btn">‚ñº</span></h3>
            <div class="panel-content">
            <div class="effect-grid">
                <div class="effect-item">
                    <button class="effect-btn" data-effect="glitch">Glitch</button>
                    <div class="effect-slider" id="glitchSliderContainer">
                        <input type="range" id="glitchIntensity" min="0" max="100" value="50">
                        <div class="effect-slider-value"><span id="glitchIntensityValue">50%</span></div>
                    </div>
                </div>
                <div class="effect-item">
                    <button class="effect-btn" data-effect="pulse">Pulse</button>
                    <div class="effect-slider" id="pulseSliderContainer">
                        <input type="range" id="pulseIntensity" min="0" max="100" value="50">
                        <div class="effect-slider-value"><span id="pulseIntensityValue">50%</span></div>
                    </div>
                </div>
                <div class="effect-item">
                    <button class="effect-btn" data-effect="edge">Edge</button>
                    <div class="effect-slider" id="edgeSliderContainer">
                        <input type="range" id="edgeIntensity" min="0" max="100" value="50">
                        <div class="effect-slider-value">St√§rke: <span id="edgeIntensityValue">50%</span></div>
                        <input type="range" id="edgeGlow" min="0" max="100" value="30" style="margin-top:2px;">
                        <div class="effect-slider-value">Glow: <span id="edgeGlowValue">30%</span></div>
                    </div>
                </div>
                <div class="effect-item">
                    <button class="effect-btn" data-effect="explode">Explode</button>
                    <div class="effect-slider" id="explodeSliderContainer">
                        <input type="range" id="explodeIntensity" min="0" max="100" value="50">
                        <div class="effect-slider-value"><span id="explodeIntensityValue">50%</span></div>
                    </div>
                </div>
                <div class="effect-item">
                    <button class="effect-btn" data-effect="particles">‚ú® Partikel</button>
                    <div class="effect-slider" id="particlesSliderContainer">
                        <input type="range" id="particlesIntensity" min="0" max="100" value="50">
                        <div class="effect-slider-value">Menge: <span id="particlesIntensityValue">50%</span></div>
                        <input type="range" id="particlesSize" min="0" max="100" value="30" style="margin-top:2px;">
                        <div class="effect-slider-value">Gr√∂√üe: <span id="particlesSizeValue">30%</span></div>
                    </div>
                </div>
                <div class="effect-item">
                    <button class="effect-btn" data-effect="trails">‚òÅ Trails</button>
                    <div class="effect-slider" id="trailsSliderContainer">
                        <input type="range" id="trailsIntensity" min="0" max="100" value="70">
                        <div class="effect-slider-value">Nachhall: <span id="trailsIntensityValue">70%</span></div>
                    </div>
                </div>
            </div>
            <div class="interaction-mode">
                <label>
                    <input type="checkbox" id="audioScaleEnabled">
                    Audio ‚Üí Skalierung
                </label>
            </div>
            <div class="slider-group" id="audioScaleControl" style="opacity:0.5;">
                <label>Skalierungs-St√§rke</label>
                <div class="slider-row">
                    <input type="range" id="audioScaleAmount" min="0" max="100" value="30" disabled>
                    <span id="audioScaleAmountValue">30%</span>
                </div>
            </div>
            <div class="interaction-mode">
                <label>
                    <input type="checkbox" id="gainLinked">
                    Audio ‚Üí Helligkeit
                </label>
            </div>
            <div class="slider-group">
                <label>Schwarzwert</label>
                <div class="slider-row">
                    <input type="range" id="blackLevel" min="0" max="50" value="0">
                    <span id="blackLevelValue">0</span>
                </div>
            </div>
            <button class="reset-btn" id="resetAllBtn" title="Alle Effekte & Artefakte zur√ºcksetzen">‚ö†Ô∏è Reset All</button>
            </div>
        </div>
        
        <!-- AI Bild -->
        <div class="panel" id="panelAiBild">
            <h3><span>AI Bild</span><span class="minimize-btn">‚ñº</span></h3>
            <div class="panel-content">
            
            <!-- Display Mode -->
            <div class="ai-mode-selector">
                <button class="ai-mode-btn active" data-aimode="off">Off</button>
                <button class="ai-mode-btn" data-aimode="on">On</button>
                <button class="ai-mode-btn" data-aimode="overlay">Overlay</button>
            </div>
            
            <!-- Provider-Tabs -->
            <div class="ai-provider-tabs">
                <button class="ai-provider-tab active" data-provider="local">üñ•Ô∏è Local</button>
                <button class="ai-provider-tab" data-provider="mix">üåÄ Mix</button>
                <button class="ai-provider-tab" data-provider="settings">‚öôÔ∏è</button>
            </div>
            
            <!-- Settings Panel (hidden by default) -->
            <div id="aiSettingsPanel" style="display: none; padding: 6px; background: #111; border-radius: 3px; margin-top: 4px;">
                <div style="font-size: 8px; color: #888; margin-bottom: 4px;">Local Stable Diffusion (ComfyUI)</div>
                <div class="slider-group" style="margin-bottom: 4px;">
                    <label style="font-size: 7px;">üñ•Ô∏è WebUI URL</label>
                    <input type="text" id="localSdUrl" placeholder="http://127.0.0.1:8188" style="width: 100%; padding: 3px; font-size: 8px; background: #222; border: 1px solid #444; border-radius: 2px; color: #fff;">
                </div>
                <button id="saveApiKeys" class="reset-btn" style="margin-top: 4px; width: 100%; font-size: 8px;">üíæ Speichern</button>
                <div id="apiKeyStatus" style="font-size: 7px; color: #4f4; margin-top: 4px;"></div>
            </div>
            
            <!-- Modell-Auswahl (Provider-spezifisch) -->
            <div id="aiModelSelector" style="margin-top: 4px;">
                <!-- Local Stable Diffusion -->
                <div class="ai-model-group" data-provider="local">
                    <div class="ai-model-tabs">
                        <button class="ai-model-tab active" data-model="local-sd15">üé® SD 1.5</button>
                        <button class="ai-model-tab" data-model="local-sdxl">üñºÔ∏è SDXL</button>
                        <button class="ai-model-tab" data-model="local-turbo">‚ö° Turbo</button>
                    </div>
                    <div id="localSdStatus" style="font-size: 7px; color: #888; margin-top: 2px;">üñ•Ô∏è Verbinde mit localhost:8188</div>
                    <button id="startComfyBtn" class="reset-btn" style="margin-top: 4px; font-size: 7px; padding: 3px 6px;">üöÄ ComfyUI starten</button>
                </div>
                <!-- Mix-Ansicht (alle Buffer) -->
                <div class="ai-model-group" data-provider="mix" style="display: none;">
                    <div id="aiMixOverview" style="font-size: 8px; color: #888; padding: 4px; background: #111; border-radius: 3px;">
                        <div style="color: #4af; margin-bottom: 4px;">üåÄ Alle Buffer kombiniert</div>
                        <div id="aiMixStats"></div>
                    </div>
                </div>
            </div>
            
            <!-- Buffer Status f√ºr aktuelles Modell -->
            <div id="aiModelBufferStatus" style="font-size: 8px; color: #888; margin-top: 4px;"></div>
            
            <!-- Gemeinsame Einstellungen -->
            <div class="interaction-mode" style="margin-top: 4px;">
                <label>
                    <input type="checkbox" id="aiAutoGenerate">
                    Auto-Generierung
                </label>
            </div>
            <div class="interaction-mode">
                <label>
                    <input type="checkbox" id="aiBufferMode">
                    Buffer-Modus
                </label>
            </div>
            
            <div id="aiBufferSettings" style="display:none; padding: 4px; background: #111; border-radius: 3px; margin-top: 4px;">
                <div class="slider-group">
                    <label>Buffer-Gr√∂√üe</label>
                    <div class="slider-row">
                        <input type="range" id="aiBufferSize" min="5" max="50" value="24">
                        <span id="aiBufferSizeValue">24</span>
                    </div>
                </div>
                <div class="slider-group">
                    <label>FPS</label>
                    <div class="ai-mode-selector" style="margin-top: 2px;">
                        <button class="ai-mode-btn" data-fps="0">Off</button>
                        <button class="ai-mode-btn" data-fps="1">1</button>
                        <button class="ai-mode-btn" data-fps="12">12</button>
                        <button class="ai-mode-btn active" data-fps="24">24</button>
                    </div>
                </div>
                <div class="interaction-mode">
                    <label>
                        <input type="checkbox" id="aiBeatSync">
                        Beat-Sync üî¥
                    </label>
                </div>
                <div class="slider-group">
                    <label>Parallel</label>
                    <div class="slider-row">
                        <input type="range" id="aiParallelGen" min="1" max="3" value="1">
                        <span id="aiParallelGenValue">1</span>
                    </div>
                </div>
                <div id="aiBufferStatus" style="font-size: 8px; color: #4f4; margin-top: 4px;">Buffer: 0/24</div>
            </div>
            
            
            <!-- Prompt Eingabe -->
            <div style="display: flex; gap: 4px; margin-top: 4px;">
                <input type="text" id="aiPromptInput" placeholder="Prompt eingeben..." style="flex: 1; padding: 4px 6px; font-size: 9px; background: #222; border: 1px solid #444; border-radius: 3px; color: #fff;">
                <button class="reset-btn" id="aiClearPrompt" style="margin: 0; width: auto; padding: 4px 6px; font-size: 8px;" title="Prompt l√∂schen">‚ùå</button>
                <button class="reset-btn" id="aiGenerateBtn" style="margin: 0; width: auto; padding: 4px 8px;">üé®</button>
            </div>
            
            <!-- Textfilter Optionen -->
            <div style="display: flex; gap: 8px; margin-top: 4px; font-size: 8px; color: #888;">
                <label style="display: flex; align-items: center; gap: 3px;">
                    <input type="checkbox" id="aiFilterNouns" checked>
                    Substantive
                </label>
                <label style="display: flex; align-items: center; gap: 3px;">
                    <input type="checkbox" id="aiFilterVerbs">
                    Verben
                </label>
                <label style="display: flex; align-items: center; gap: 3px;">
                    <input type="checkbox" id="aiFilterAdj">
                    Adjektive
                </label>
            </div>
            
            <div id="aiCurrentInput" style="font-size: 7px; color: #666; margin-top: 2px; padding: 2px 4px; background: #0a0a0a; border-radius: 2px; min-height: 12px; word-break: break-word;">üé§ -</div>
            <!-- Preview & Thumbnails -->
            <div id="aiImagePreview">
                <span class="placeholder">Kein Bild</span>
            </div>
            <div id="aiBufferThumbs"></div>
            
            <!-- Crossfade -->
            <div class="interaction-mode" style="margin-top: 6px;">
                <label>
                    <input type="checkbox" id="aiCrossfadeEnabled">
                    Crossfade
                </label>
            </div>
            <div id="aiCrossfadeSettings" class="slider-group" style="margin-top: 4px; display: none;">
                <div class="slider-row">
                    <input type="range" id="aiCrossfadeDuration" min="0.1" max="2" step="0.1" value="0.5">
                    <span id="aiCrossfadeDurationValue">0.5s</span>
                </div>
            </div>
            <div id="aiStats" style="font-size: 7px; color: #666; margin-top: 3px;"></div>
            </div>
        </div>
    </div>
    
    <!-- AI Bild Container (nicht mehr verwendet - Canvas Overlay stattdessen) -->
    <div id="aiImageContainer" style="display:none !important;">
        <img id="aiImage" src="" alt="AI Generated" crossorigin="anonymous">
        <div id="aiImageStatus"></div>
    </div>
    
    <!-- Rechtes Panel: Master & EQ -->
    <div id="ui-right">
        <div class="panel">
            <h3>Master</h3>
            <div class="fader-container">
                <div class="fader-value" id="gainValue">0 dB</div>
                <div class="fader-track">
                    <input type="range" id="masterGain" min="-60" max="12" step="0.5" value="0">
                    <div class="fader-db-marks">
                        <span>+12</span>
                        <span>0</span>
                        <span>-60</span>
                    </div>
                </div>
                <div class="fader-label">Gain</div>
            </div>
            <div class="level-meter">
                <div class="level-meter-fill" id="levelMeter"></div>
            </div>
        </div>
        
        <div class="panel">
            <h3>Input EQ</h3>
            <div class="eq-container">
                <div class="eq-band">
                    <label><span>Low</span><span id="eqLowValue">0</span></label>
                    <input type="range" id="eqLow" min="-24" max="24" step="0.5" value="0">
                </div>
                <div class="eq-band">
                    <label><span>Mid</span><span id="eqMidValue">0</span></label>
                    <input type="range" id="eqMid" min="-24" max="24" step="0.5" value="0">
                </div>
                <div class="eq-band">
                    <label><span>High</span><span id="eqHighValue">0</span></label>
                    <input type="range" id="eqHigh" min="-24" max="24" step="0.5" value="0">
                </div>
            </div>
            <button class="reset-btn" id="eqReset">Reset</button>
        </div>
        
        <div class="panel">
            <h3>Pitch Detection</h3>
            <div class="slider-group">
                <label>Reaktionsgeschwindigkeit</label>
                <div class="slider-row">
                    <input type="range" id="reactionSpeed" min="0" max="100" value="70">
                    <span id="reactionSpeedValue">70%</span>
                </div>
            </div>
            <div class="algo-grid" id="algoGrid">
                <!-- Wird per JS gef√ºllt -->
            </div>
            <div class="algo-combine">
                <label>Kombination:</label>
                <select id="algoCombineMode">
                    <option value="union">Union (alle T√∂ne)</option>
                    <option value="intersection">Schnittmenge</option>
                    <option value="voting">Voting (Mehrheit)</option>
                    <option value="strongest">St√§rkste Confidence</option>
                </select>
            </div>
            <div class="algo-description" id="algoDescription">
                Klicke mehrere Algorithmen f√ºr Ensemble-Erkennung
            </div>
        </div>
        
        <div class="panel">
            <h3>Beat</h3>
            <div class="beat-display">
                <div class="bpm-value" id="bpmValue">-- BPM</div>
                <div class="beat-indicator" id="beatIndicator"></div>
            </div>
            <div class="slider-group">
                <label>Empfindlichkeit</label>
                <div class="slider-row">
                    <input type="range" id="beatSensitivity" min="0" max="100" value="50">
                    <span id="beatSensitivityValue">50%</span>
                </div>
            </div>
            <div class="interaction-mode">
                <label>
                    <input type="checkbox" id="beatFlashEnabled" checked>
                    Flash
                </label>
            </div>
            <div class="interaction-mode">
                <label>
                    <input type="checkbox" id="beatPulseEnabled">
                    Pulse
                </label>
            </div>
            <div class="interaction-mode">
                <label>
                    <input type="checkbox" id="beatRotationEnabled">
                    Beat-Rotation
                </label>
            </div>
            <div class="slider-group">
                <label>Rotation</label>
                <div class="slider-row">
                    <input type="range" id="rotationSpeed" min="0" max="100" value="20">
                    <span id="rotationSpeedValue">20%</span>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <h3>Kamera</h3>
            <div class="interaction-mode">
                <label>
                    <input type="checkbox" id="cameraLocked">
                    Position sperren
                </label>
            </div>
            <button class="reset-btn" id="cameraResetBtn" style="margin-top:0;">‚åÇ Standardposition</button>
            <button class="reset-btn" id="cameraOrbitBtn" style="margin-top:4px;">‚Üª Auto-Orbit</button>
            <div class="slider-group">
                <label>Brennweite (FOV)</label>
                <div class="slider-row">
                    <input type="range" id="cameraFov" min="20" max="120" value="50">
                    <span id="cameraFovValue">50¬∞</span>
                </div>
            </div>
            <div class="interaction-mode">
                <label>
                    <input type="checkbox" id="fovAudioLinked">
                    FOV ‚Üí Audio
                </label>
            </div>
            <div class="slider-group" id="fovAudioControl" style="opacity:0.5;">
                <label>FOV-Reaktion</label>
                <div class="slider-row">
                    <input type="range" id="fovAudioAmount" min="0" max="100" value="30" disabled>
                    <span id="fovAudioAmountValue">30%</span>
                </div>
            </div>
            <div class="slider-group">
                <label>Blur (Tiefenunsch√§rfe)</label>
                <div class="slider-row">
                    <input type="range" id="cameraBlur" min="0" max="100" value="0">
                    <span id="cameraBlurValue">0%</span>
                </div>
            </div>
        </div>
    </div>
    
    <canvas id="canvas"></canvas>
    <canvas id="aiOverlayCanvas"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';

        // ============================================
        // FARBSCHEMATA
        // ============================================
        
        // Clara: Absolute Tonfarben (maximale S√§ttigung nach Original-Bild)
        const ClaraColors = {
            notes: {
                //       Grundton        #-Ton (heller)   b-Ton (dunkler)
                'C':  { base: 0xff0000, sharp: 0xff6666, flat: 0xdd0000 },  // C = Reines Rot
                'D':  { base: 0xffff00, sharp: 0xffff77, flat: 0xdddd00 },  // D = Reines Gelb
                'E':  { base: 0x00ff00, sharp: null,     flat: 0x00cc00 },  // E = Reines Gr√ºn
                'F':  { base: 0xff8800, sharp: 0xffaa44, flat: null },      // F = Kr√§ftiges Orange
                'G':  { base: 0x0066ff, sharp: 0x66aaff, flat: 0x0044cc },  // G = Kr√§ftiges Blau
                'A':  { base: 0x999999, sharp: 0xbbbbbb, flat: 0x666666 },  // A = Grau
                'B':  { base: 0x8B4513, sharp: null,     flat: 0x5D2E0C },  // H = Braun
            },
            intervals: {
                0:  'prime',
                1:  'sekunde_klein',
                2:  'sekunde_gross', 
                3:  'terz_klein',
                4:  'terz_gross',
                5:  'quarte',
                6:  'tritonus',
                7:  'quinte',
                8:  'sexte_klein',
                9:  'sexte_gross',
                10: 'septime_klein',
                11: 'septime_gross',
                12: 'oktave'
            },
            digits: {
                0: 0xffffff, 1: 0xff0000, 2: 0xff6699, 3: 0xffcc00,
                4: 0x996633, 5: 0x99cc00, 6: 0x00cc66,
                7: 0x66cccc, 8: 0xff9900, 9: 0xcc99ff
            }
        };
        
        // Alex: Relative Akkordfarben
        const AlexColors = {
            modes: {
                'minor': 0x3366cc,
                'major': 0xff6633,
            },
            // Erweiterte Stufenfarben mit mehr Variation
            degrees: {
                0:  0xff2222,  // I - Rot (Tonika)
                1:  0xe6b800,  // bII - Gold/Gelb (Neapolitaner)
                2:  0xffee55,  // II - Helles Gelb
                3:  0x2255dd,  // bIII - Tiefes Blau (Moll-Terz)
                4:  0x44aaff,  // III - Hellblau (Dur-Terz)
                5:  0xff5500,  // IV - Orange (Subdominante)
                6:  0x9922cc,  // #IV/b5 - Violett (Tritonus)
                7:  0xffcc00,  // V - Gelb-Gold (Dominante)
                8:  0x3344aa,  // bVI - Dunkelblau
                9:  0x22cc66,  // VI - Gr√ºn
                10: 0xff8833,  // bVII - Helles Orange
                11: 0xcc4422,  // VII - Rotbraun (Leitton)
            },
            // Sekund√§rfarben f√ºr Gradienten
            degreesSecondary: {
                0:  0xff6644,  // I
                1:  0xffdd33,  // bII
                2:  0xffffaa,  // II
                3:  0x4477ff,  // bIII
                4:  0x88ccff,  // III
                5:  0xffaa33,  // IV
                6:  0xcc44ff,  // #IV
                7:  0xffee66,  // V
                8:  0x5566cc,  // bVI
                9:  0x44ee88,  // VI
                10: 0xffbb66,  // bVII
                11: 0xff6633,  // VII
            },
            degreeNames: {
                0: 'I', 1: 'bII', 2: 'II', 3: 'bIII', 4: 'III', 5: 'IV',
                6: '#IV', 7: 'V', 8: 'bVI', 9: 'VI', 10: 'bVII', 11: 'VII'
            }
        };
        
        // Gradient-Modus f√ºr Alex-Farben
        let alexGradientEnabled = false;
        let alexVignetteEnabled = false;
        const vignetteOverlay = document.getElementById('vignetteOverlay');
        
        // Vignette-Farbe f√ºr Stream (wird in applyColors aktualisiert)
        let currentVignetteColor = null; // { r, g, b, a } oder null wenn inaktiv

        // ============================================
        // INTERVALL-DEFINITIONEN
        // ============================================
        
        const IntervalNames = {
            0:  { name: 'Prime', short: 'P1' },
            1:  { name: 'Kleine Sekunde', short: 'm2' },
            2:  { name: 'Gro√üe Sekunde', short: 'M2' },
            3:  { name: 'Kleine Terz', short: 'm3' },
            4:  { name: 'Gro√üe Terz', short: 'M3' },
            5:  { name: 'Quarte', short: 'P4' },
            6:  { name: 'Tritonus', short: 'TT' },
            7:  { name: 'Quinte', short: 'P5' },
            8:  { name: 'Kleine Sexte', short: 'm6' },
            9:  { name: 'Gro√üe Sexte', short: 'M6' },
            10: { name: 'Kleine Septime', short: 'm7' },
            11: { name: 'Gro√üe Septime', short: 'M7' },
            12: { name: 'Oktave', short: 'P8' },
            // Intervalle √ºber der Oktave
            13: { name: 'Kleine None', short: 'm9' },
            14: { name: 'Gro√üe None', short: 'M9' },
            15: { name: 'Kleine Dezime', short: 'm10' },
            16: { name: 'Gro√üe Dezime', short: 'M10' },
            17: { name: 'Undezime', short: 'P11' },
            18: { name: '√úberm. Undezime', short: '#11' },
            19: { name: 'Duodezime', short: 'P12' },
            20: { name: 'Kleine Tredezime', short: 'm13' },
            21: { name: 'Gro√üe Tredezime', short: 'M13' },
            22: { name: 'Kleine Quartdezime', short: 'm14' },
            23: { name: 'Gro√üe Quartdezime', short: 'M14' },
            24: { name: 'Doppeloktave', short: 'P15' },
        };
        
        const IntervalModels = {
            0:  'prime.glb',           // Prime
            1:  'sekunde.glb',         // kleine Sekunde
            2:  'sekunde.glb',         // gro√üe Sekunde
            3:  'terz-klein.glb',      // kleine Terz
            4:  'terz-gross.glb',      // gro√üe Terz
            5:  'quarte.glb',          // Quarte
            6:  'quarte.glb',          // Tritonus (Fallback)
            7:  'quinte.glb',          // Quinte
            8:  'sexte_1.glb',         // kleine Sexte
            9:  'sexte_1.glb',         // gro√üe Sexte
            10: 'septime_klein.glb',   // kleine Septime
            11: 'septime_klein.glb',   // gro√üe Septime (Fallback)
            12: 'oktave.glb',          // Oktave
            // Nonen (Oktave + Sekunde)
            13: 'sekunde.glb',         // kleine None
            14: 'sekunde.glb',         // gro√üe None
            // Dezimen (Oktave + Terz)
            15: 'terz-klein.glb',      // kleine Dezime
            16: 'dezime_gross.glb',    // gro√üe Dezime
            // Undezimen (Oktave + Quarte)
            17: 'quarte.glb',          // Undezime
            18: 'quarte.glb',          // √ºberm. Undezime
            // Duodezime (Oktave + Quinte)
            19: 'quinte.glb',          // Duodezime
            // Tredezimen (Oktave + Sexte)
            20: 'sexte_1.glb',         // kleine Tredezime
            21: 'sexte_1.glb',         // gro√üe Tredezime
            // Quartdezimen (Oktave + Septime)
            22: 'septime_klein.glb',   // kleine Quartdezime
            23: 'septime_klein.glb',   // gro√üe Quartdezime
            // Doppeloktave
            24: 'oktave.glb',          // Doppeloktave
        };
        
        // Funktion um Modell f√ºr beliebiges Intervall zu finden
        function getModelForInterval(semitones) {
            // Direkte Zuordnung wenn vorhanden
            if (IntervalModels[semitones]) {
                return IntervalModels[semitones];
            }
            // Fallback: Auf Oktav-√Ñquivalent reduzieren
            const reduced = semitones % 12;
            return IntervalModels[reduced] || 'prime.glb';
        }
        
        // Alle verf√ºgbaren Modelle mit Display-Namen
        const AvailableModels = [
            { file: 'none_klein.glb', name: 'None/Prime' },
            { file: 'sekunde.glb', name: 'Sekunde' },
            { file: 'terz-gross.glb', name: 'Terz' },
            { file: 'quarte.glb', name: 'Quarte' },
            { file: 'quinte.glb', name: 'Quinte' },
            { file: 'sexte_1.glb', name: 'Sexte' },
            { file: 'septime_klein.glb', name: 'Septime' },
            { file: 'oktave.glb', name: 'Oktave' }
        ];

        // ============================================
        // THREE.JS SETUP
        // ============================================
        
        const canvas = document.getElementById('canvas');
        const aiOverlayCanvas = document.getElementById('aiOverlayCanvas');
        const aiOverlayCtx = aiOverlayCanvas.getContext('2d');
        
        // Overlay Canvas Gr√∂√üe setzen
        aiOverlayCanvas.width = window.innerWidth;
        aiOverlayCanvas.height = window.innerHeight;
        
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ 
            canvas, 
            antialias: true,
            preserveDrawingBuffer: true  // Wichtig f√ºr Stream/Screenshot!
        });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000); // Reines Schwarz RGB(0,0,0)

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        
        const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
        backLight.position.set(-5, 3, -5);
        scene.add(backLight);

        camera.position.set(0, 2, 5);
        const controls = new OrbitControls(camera, canvas);
        controls.enableDamping = true;
        
        // ============================================
        // EDGE DETECTION POST-PROCESSING
        // ============================================
        
        // Sobel Edge Detection Shader
        const EdgeDetectionShader = {
            uniforms: {
                'tDiffuse': { value: null },
                'resolution': { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                'edgeStrength': { value: 1.0 },
                'edgeGlow': { value: 0.0 },
                'edgeColor': { value: new THREE.Vector3(1.0, 1.0, 1.0) },
                'backgroundColor': { value: new THREE.Vector3(0.0, 0.0, 0.0) },
                'useOriginalColor': { value: true }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 resolution;
                uniform float edgeStrength;
                uniform float edgeGlow;
                uniform vec3 edgeColor;
                uniform vec3 backgroundColor;
                uniform bool useOriginalColor;
                
                varying vec2 vUv;
                
                void main() {
                    vec2 texel = vec2(1.0 / resolution.x, 1.0 / resolution.y);
                    
                    // Sample 3x3 neighborhood
                    vec4 n[9];
                    n[0] = texture2D(tDiffuse, vUv + texel * vec2(-1, -1));
                    n[1] = texture2D(tDiffuse, vUv + texel * vec2( 0, -1));
                    n[2] = texture2D(tDiffuse, vUv + texel * vec2( 1, -1));
                    n[3] = texture2D(tDiffuse, vUv + texel * vec2(-1,  0));
                    n[4] = texture2D(tDiffuse, vUv);
                    n[5] = texture2D(tDiffuse, vUv + texel * vec2( 1,  0));
                    n[6] = texture2D(tDiffuse, vUv + texel * vec2(-1,  1));
                    n[7] = texture2D(tDiffuse, vUv + texel * vec2( 0,  1));
                    n[8] = texture2D(tDiffuse, vUv + texel * vec2( 1,  1));
                    
                    // Sobel operator
                    vec4 sobelH = n[2] + (2.0 * n[5]) + n[8] - (n[0] + (2.0 * n[3]) + n[6]);
                    vec4 sobelV = n[0] + (2.0 * n[1]) + n[2] - (n[6] + (2.0 * n[7]) + n[8]);
                    
                    // Edge magnitude
                    vec4 sobel = sqrt(sobelH * sobelH + sobelV * sobelV);
                    float edge = (sobel.r + sobel.g + sobel.b) / 3.0;
                    
                    // Apply strength
                    edge = clamp(edge * edgeStrength * 3.0, 0.0, 1.0);
                    
                    // Output
                    vec3 originalColor = n[4].rgb;
                    vec3 lineColor = useOriginalColor ? originalColor : edgeColor;
                    
                    // Glow effect - add original color influence
                    vec3 glowColor = originalColor * edgeGlow * edge;
                    
                    // Final color: edge lines + optional glow
                    vec3 finalColor = mix(backgroundColor, lineColor, edge) + glowColor;
                    
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `
        };
        
        // EffectComposer Setup
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        
        // Edge Detection Pass
        const edgePass = new ShaderPass(EdgeDetectionShader);
        edgePass.enabled = false; // Startet deaktiviert
        composer.addPass(edgePass);
        
        // Edge-Effekt Einstellungen
        let edgeEffectEnabled = false;
        let edgeStrength = 1.0;
        let edgeGlow = 0.3;
        
        // ============================================
        // BLUR POST-PROCESSING (Multi-Pass Gaussian)
        // ============================================
        
        // Gaussian Blur Shader - f√ºr iterative Anwendung optimiert
        const BlurShader = {
            uniforms: {
                'tDiffuse': { value: null },
                'resolution': { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                'direction': { value: new THREE.Vector2(1.0, 0.0) },
                'radius': { value: 1.0 } // Skaliert den Blur-Radius
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 resolution;
                uniform vec2 direction;
                uniform float radius;
                
                varying vec2 vUv;
                
                void main() {
                    vec2 texel = direction / resolution * radius;
                    
                    // 9-tap Gaussian blur (sigma ~2)
                    vec4 sum = vec4(0.0);
                    sum += texture2D(tDiffuse, vUv - 4.0 * texel) * 0.0162162162;
                    sum += texture2D(tDiffuse, vUv - 3.0 * texel) * 0.0540540541;
                    sum += texture2D(tDiffuse, vUv - 2.0 * texel) * 0.1216216216;
                    sum += texture2D(tDiffuse, vUv - 1.0 * texel) * 0.1945945946;
                    sum += texture2D(tDiffuse, vUv) * 0.2270270270;
                    sum += texture2D(tDiffuse, vUv + 1.0 * texel) * 0.1945945946;
                    sum += texture2D(tDiffuse, vUv + 2.0 * texel) * 0.1216216216;
                    sum += texture2D(tDiffuse, vUv + 3.0 * texel) * 0.0540540541;
                    sum += texture2D(tDiffuse, vUv + 4.0 * texel) * 0.0162162162;
                    
                    gl_FragColor = sum;
                }
            `
        };
        
        // Mehrere Blur-Pass-Paare f√ºr iterativen Blur
        // Jedes Paar = 1x horizontal + 1x vertikal
        const blurPasses = [];
        const MAX_BLUR_ITERATIONS = 8; // 8 Iterationen = sehr starker Blur m√∂glich
        
        for (let i = 0; i < MAX_BLUR_ITERATIONS; i++) {
            const passH = new ShaderPass(BlurShader);
            passH.uniforms.direction.value.set(1.0, 0.0);
            passH.enabled = false;
            composer.addPass(passH);
            
            const passV = new ShaderPass(BlurShader);
            passV.uniforms.direction.value.set(0.0, 1.0);
            passV.enabled = false;
            composer.addPass(passV);
            
            blurPasses.push({ h: passH, v: passV });
        }
        
        // Blur-Einstellung
        let blurAmount = 0;
        
        // Blur-Intensit√§t setzen (0-1)
        function setBlurIntensity(intensity) {
            blurAmount = intensity;
            
            // Anzahl aktiver Iterationen basierend auf Intensit√§t
            // 0% = 0 Iterationen, 100% = alle 8 Iterationen
            const activeIterations = Math.ceil(intensity * MAX_BLUR_ITERATIONS);
            
            // Radius skalieren: 1 bei 0%, 100 bei 100%
            const radius = 1 + intensity * 99;
            
            blurPasses.forEach((pair, index) => {
                const isActive = index < activeIterations && intensity > 0;
                pair.h.enabled = isActive;
                pair.v.enabled = isActive;
                pair.h.uniforms.radius.value = radius;
                pair.v.uniforms.radius.value = radius;
            });
        }
        
        // ============================================
        // TRAIL/AFTERIMAGE POST-PROCESSING
        // ============================================
        
        // Verwende den offiziellen Three.js AfterimagePass
        const afterimagePass = new AfterimagePass();
        afterimagePass.uniforms['damp'].value = 0.9; // 0 = kein Trail, 1 = komplett
        afterimagePass.enabled = false;
        composer.addPass(afterimagePass);
        
        let trailsEnabled = false;
        let trailsIntensity = 0.7;
        
        function setTrailsIntensity(intensity) {
            trailsIntensity = intensity;
            // damp: 0.8 (wenig Trail) bis 0.97 (starker Trail)
            afterimagePass.uniforms['damp'].value = 0.8 + intensity * 0.17;
        }
        
        // ============================================
        // PARTIKEL-SYSTEM
        // ============================================
        
        const PARTICLE_COUNT = 2000;
        let particlesEnabled = false;
        let particlesIntensity = 0.5;
        let particlesSize = 0.3;
        let particleSystem = null;
        let particlePositions = null;
        let particleVelocities = null;
        let particleColors = null;
        let particleSizes = null;
        let particleLifetimes = null;
        
        // Partikel-System initialisieren
        function initParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            
            particlePositions = new Float32Array(PARTICLE_COUNT * 3);
            particleVelocities = new Float32Array(PARTICLE_COUNT * 3);
            particleColors = new Float32Array(PARTICLE_COUNT * 3);
            particleSizes = new Float32Array(PARTICLE_COUNT);
            particleLifetimes = new Float32Array(PARTICLE_COUNT);
            
            // Initialisiere Partikel
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                resetParticle(i);
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
            
            // Shader-Material f√ºr Partikel mit Gr√∂√üenvariation
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    pointMultiplier: { value: window.innerHeight / 2 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float pointMultiplier;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * pointMultiplier / -mvPosition.z;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        // Weicher Kreis
                        float r = length(gl_PointCoord - vec2(0.5));
                        if (r > 0.5) discard;
                        float alpha = 1.0 - smoothstep(0.3, 0.5, r);
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            
            particleSystem = new THREE.Points(geometry, material);
            particleSystem.visible = false;
            scene.add(particleSystem);
        }
        
        // Einzelnes Partikel zur√ºcksetzen
        function resetParticle(i) {
            const i3 = i * 3;
            
            // Zuf√§llige Position um das Zentrum
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const radius = 1 + Math.random() * 2;
            
            particlePositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
            particlePositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            particlePositions[i3 + 2] = radius * Math.cos(phi);
            
            // Geschwindigkeit nach au√üen
            const speed = 0.02 + Math.random() * 0.03;
            particleVelocities[i3] = particlePositions[i3] * speed;
            particleVelocities[i3 + 1] = particlePositions[i3 + 1] * speed;
            particleVelocities[i3 + 2] = particlePositions[i3 + 2] * speed;
            
            // Standard-Farbe (wird sp√§ter von Notenfarbe √ºberschrieben)
            particleColors[i3] = 1;
            particleColors[i3 + 1] = 1;
            particleColors[i3 + 2] = 1;
            
            // Gr√∂√üe und Lifetime
            particleSizes[i] = 0.02 + Math.random() * 0.05;
            particleLifetimes[i] = Math.random(); // 0-1 Lifecycle
        }
        
        // Partikel updaten
        function updateParticles(deltaTime, audioLevel) {
            if (!particleSystem || !particlesEnabled) return;
            
            const positions = particleSystem.geometry.attributes.position.array;
            const sizes = particleSystem.geometry.attributes.size.array;
            const colors = particleSystem.geometry.attributes.color.array;
            
            // Wie viele Partikel aktiv sind (basierend auf Intensit√§t)
            const activeCount = Math.floor(PARTICLE_COUNT * particlesIntensity);
            
            // Audio-Boost
            const audioBoost = 1 + audioLevel * 2;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                if (i < activeCount) {
                    // Lifetime erh√∂hen
                    particleLifetimes[i] += deltaTime * (0.3 + audioLevel * 0.5);
                    
                    // Wenn Lifetime abgelaufen, reset
                    if (particleLifetimes[i] > 1) {
                        resetParticle(i);
                    }
                    
                    // Position updaten
                    positions[i3] += particleVelocities[i3] * audioBoost;
                    positions[i3 + 1] += particleVelocities[i3 + 1] * audioBoost;
                    positions[i3 + 2] += particleVelocities[i3 + 2] * audioBoost;
                    
                    // Gr√∂√üe basierend auf Lifecycle und Audio (fade out)
                    const lifeFactor = 1 - particleLifetimes[i];
                    sizes[i] = particleSizes[i] * particlesSize * 3 * lifeFactor * audioBoost;
                } else {
                    // Inaktive Partikel unsichtbar machen
                    sizes[i] = 0;
                }
            }
            
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.size.needsUpdate = true;
        }
        
        // Partikelfarben basierend auf aktueller Notenfarbe setzen
        function setParticleColor(color) {
            if (!particleSystem) return;
            
            const threeColor = new THREE.Color(color);
            const colors = particleSystem.geometry.attributes.color.array;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                // Leichte Variation
                const variation = 0.8 + Math.random() * 0.4;
                colors[i3] = threeColor.r * variation;
                colors[i3 + 1] = threeColor.g * variation;
                colors[i3 + 2] = threeColor.b * variation;
            }
            
            particleSystem.geometry.attributes.color.needsUpdate = true;
        }
        
        // Partikel-System initialisieren
        initParticleSystem();
        
        // ============================================
        // KAMERA-STEUERUNG
        // ============================================
        
        // Standard-Kameraposition speichern
        const defaultCameraPosition = { x: 0, y: 2, z: 5 };
        const defaultCameraTarget = { x: 0, y: 0, z: 0 };
        const defaultFov = 50;
        
        // Kamera-Variablen
        let cameraLocked = false;
        let autoOrbitEnabled = false;
        let autoOrbitSpeed = 0.005; // Radians pro Frame
        let autoOrbitAngle = 0;
        let autoOrbitRadius = 5; // Distanz zum Zentrum
        let autoOrbitHeight = 2; // H√∂he der Kamera
        
        // FOV Audio-Link
        let fovAudioLinked = false;
        let fovAudioAmount = 0.3; // 0-1
        let baseFov = 50; // Basis-FOV f√ºr Audio-Modulation
        
        // Kamera zur√ºcksetzen
        function resetCamera() {
            camera.position.set(defaultCameraPosition.x, defaultCameraPosition.y, defaultCameraPosition.z);
            camera.fov = defaultFov;
            camera.updateProjectionMatrix();
            controls.target.set(defaultCameraTarget.x, defaultCameraTarget.y, defaultCameraTarget.z);
            controls.update();
            
            // UI aktualisieren
            document.getElementById('cameraFov').value = defaultFov;
            document.getElementById('cameraFovValue').textContent = defaultFov + '¬∞';
            baseFov = defaultFov;
            
            // Auto-Orbit zur√ºcksetzen
            autoOrbitAngle = 0;
            autoOrbitRadius = Math.sqrt(
                defaultCameraPosition.x * defaultCameraPosition.x + 
                defaultCameraPosition.z * defaultCameraPosition.z
            );
        }
        
        // Auto-Orbit Toggle
        function toggleAutoOrbit() {
            autoOrbitEnabled = !autoOrbitEnabled;
            const btn = document.getElementById('cameraOrbitBtn');
            
            if (autoOrbitEnabled) {
                btn.style.background = 'linear-gradient(135deg, #44aaff, #4488ff)';
                btn.style.color = '#fff';
                // Aktuelle Position als Startpunkt verwenden
                autoOrbitRadius = Math.sqrt(
                    camera.position.x * camera.position.x + 
                    camera.position.z * camera.position.z
                );
                autoOrbitHeight = camera.position.y;
                autoOrbitAngle = Math.atan2(camera.position.x, camera.position.z);
                // Controls deaktivieren w√§hrend Auto-Orbit
                controls.enabled = false;
            } else {
                btn.style.background = '';
                btn.style.color = '';
                controls.enabled = !cameraLocked;
            }
        }
        
        // Auto-Orbit Update (wird in animate() aufgerufen)
        function updateAutoOrbit() {
            if (!autoOrbitEnabled) return;
            
            autoOrbitAngle += autoOrbitSpeed;
            
            // Kreisbahn um Zentrum
            camera.position.x = Math.sin(autoOrbitAngle) * autoOrbitRadius;
            camera.position.z = Math.cos(autoOrbitAngle) * autoOrbitRadius;
            camera.position.y = autoOrbitHeight;
            
            // Immer auf Zentrum schauen
            camera.lookAt(0, 0, 0);
        }
        
        // FOV mit Audio modulieren
        function updateFovWithAudio() {
            if (!fovAudioLinked) return;
            
            // Audio-Level auf FOV anwenden
            // Bei hohem Audio: FOV wird kleiner (Zoom-In Effekt)
            const fovModulation = currentGainLevel * fovAudioAmount * 30; // Max 30¬∞ √Ñnderung
            const newFov = baseFov - fovModulation; // Minus = Zoom bei lautem Audio
            
            camera.fov = Math.max(20, Math.min(120, newFov));
            camera.updateProjectionMatrix();
        }

        // ============================================
        // MODEL SETS & MANAGEMENT
        // ============================================
        
        const loader = new GLTFLoader();
        let currentModel = null;
        let modelMaterials = [];
        let modelCache = {};
        let currentScale = 1;
        
        // Model Sets
        let currentModelSet = ''; // '' = Legacy/Standard, 'set_01', 'set_02', etc.
        let availableModelSets = []; // Wird beim Start bef√ºllt
        let currentSetModels = {}; // Mapping: Halbt√∂ne (0-24) -> Dateiname f√ºrs aktuelle Set
        
        // Dateinummer = Halbt√∂ne (0-24)
        // 00=Prime, 01=kl.Sekunde, 02=gr.Sekunde, 03=kl.Terz, 04=gr.Terz,
        // 05=Quarte, 06=Tritonus, 07=Quinte, 08=kl.Sexte, 09=gr.Sexte,
        // 10=kl.Septime, 11=gr.Septime, 12=Oktave, 13=kl.None, 14=gr.None,
        // 15=kl.Dezime, 16=gr.Dezime, 17=Undezime, 18=√ºberm.Undezime,
        // 19=Duodezime, 20=kl.Tredezime, 21=gr.Tredezime,
        // 22=kl.Quartdezime, 23=gr.Quartdezime, 24=Doppeloktave
        
        // UI Elemente f√ºr Model Sets
        const modelSetSelect = document.getElementById('modelSetSelect');
        const scanModelSetsBtn = document.getElementById('scanModelSetsBtn');
        const modelSetStatus = document.getElementById('modelSetStatus');
        
        // Model Sets scannen und Dropdown bef√ºllen
        async function detectModelSets(showStatus = false) {
            // Reset
            availableModelSets = [];
            
            if (showStatus) {
                scanModelSetsBtn.classList.add('scanning');
                modelSetStatus.textContent = 'Scanne...';
                modelSetStatus.style.color = '#ff0';
            }
            
            // Dropdown neu aufbauen (kein Legacy-Check mehr)
            modelSetSelect.innerHTML = '';
            
            // Versuche zuerst √ºber Electron IPC
            if (window.electronAPI?.listModelSets) {
                try {
                    const sets = await window.electronAPI.listModelSets();
                    sets.forEach(setName => {
                        availableModelSets.push(setName);
                        const option = document.createElement('option');
                        option.value = setName;
                        // Formatiere den Namen sch√∂ner (set_01 -> Set 01)
                        option.textContent = setName.replace('set_', 'Set ').replace('_', ' ');
                        modelSetSelect.appendChild(option);
                    });
                    console.log(`${sets.length} Model Sets via Electron gefunden:`, sets);
                    
                    if (showStatus) {
                        scanModelSetsBtn.classList.remove('scanning');
                        modelSetStatus.textContent = `${sets.length} Sets gefunden`;
                        modelSetStatus.style.color = sets.length > 0 ? '#4f4' : '#666';
                        setTimeout(() => { modelSetStatus.textContent = ''; }, 3000);
                    }
                    return;
                } catch (e) {
                    console.warn('Electron listModelSets fehlgeschlagen:', e);
                }
            }
            
            // Fallback: HTTP HEAD requests (f√ºr Browser)
            // Intelligenter Scan: Bricht ab nach 2 aufeinanderfolgenden nicht gefundenen Sets
            let consecutiveNotFound = 0;
            const MAX_CONSECUTIVE_NOT_FOUND = 2;
            
            for (let setNum = 1; setNum <= 20 && consecutiveNotFound < MAX_CONSECUTIVE_NOT_FOUND; setNum++) {
                const setName = `set_${setNum.toString().padStart(2, '0')}`;
                
                if (showStatus) {
                    modelSetStatus.textContent = `Pr√ºfe ${setName}...`;
                }
                
                // Versuche nur die wahrscheinlichste Datei (00_prime.glb)
                const testPath = `./3d-models/${setName}/00_prime.glb`;
                let found = false;
                
                try {
                    const response = await fetch(testPath, { method: 'HEAD' });
                    found = response.ok;
                } catch (e) {
                    found = false;
                }
                
                if (found) {
                    availableModelSets.push(setName);
                    const option = document.createElement('option');
                    option.value = setName;
                    option.textContent = setName.replace('set_', 'Set ').replace('_', ' ');
                    modelSetSelect.appendChild(option);
                    console.log(`Model Set gefunden: ${setName}`);
                    consecutiveNotFound = 0; // Reset counter
                } else {
                    consecutiveNotFound++;
                }
            }
            
            console.log(`${availableModelSets.length} Model Sets gefunden`);
            
            if (showStatus) {
                scanModelSetsBtn.classList.remove('scanning');
                modelSetStatus.textContent = `${availableModelSets.length} Sets gefunden`;
                modelSetStatus.style.color = availableModelSets.length > 0 ? '#4f4' : '#666';
                setTimeout(() => { modelSetStatus.textContent = ''; }, 3000);
            }
        }
        
        // Scan-Button Event Handler
        scanModelSetsBtn.addEventListener('click', () => {
            detectModelSets(true);
        });
        
        // Modelle eines Sets scannen und cachen
        async function loadSetModels(setName) {
            currentSetModels = {};
            
            if (!setName) {
                // Legacy-Modus: Direkte Zuordnung verwenden
                return;
            }
            
            // Versuche zuerst √ºber Electron IPC
            if (window.electronAPI?.scanModelSet) {
                try {
                    const files = await window.electronAPI.scanModelSet(setName);
                    files.forEach(filename => {
                        // Extrahiere Nummer am Anfang: "00_blabla.glb" -> 0, "24_doppeloktave.glb" -> 24
                        const match = filename.match(/^(\d+)[_\-.]/);
                        if (match) {
                            const num = parseInt(match[1]);
                            if (num >= 0 && num <= 24) {
                                currentSetModels[num] = filename;
                                console.log(`Set ${setName}: ${num} Halbt√∂ne -> ${filename}`);
                            }
                        }
                    });
                    console.log(`Set ${setName} geladen: ${Object.keys(currentSetModels).length} Modelle`);
                    return;
                } catch (e) {
                    console.warn('Electron scanModelSet fehlgeschlagen:', e);
                }
            }
            
            // Fallback: HTTP HEAD requests (f√ºr Browser)
            // Versuche Modelle 00-24 mit bekannten Namen zu finden
            // Liste aller m√∂glichen Dateinamen-Suffixe
            const intervalNames = {
                0:  ['prime'],
                1:  ['sekunde_klein', 'kleine_sekunde', 'sekunde'],
                2:  ['sekunde_gross', 'grosse_sekunde', 'sekunde'],
                3:  ['terz_klein', 'kleine_terz', 'terz'],
                4:  ['terz_gross', 'grosse_terz', 'terz'],
                5:  ['quarte', 'reine_quarte'],
                6:  ['tritonus', 'tritone'],
                7:  ['quinte', 'reine_quinte'],
                8:  ['sexte_klein', 'kleine_sexte', 'sexte'],
                9:  ['sexte_gross', 'grosse_sexte', 'sexte'],
                10: ['septime_klein', 'kleine_septime', 'septime'],
                11: ['septime_gross', 'grosse_septime', 'septime'],
                12: ['oktave'],
                13: ['none_klein', 'kleine_none', 'none'],
                14: ['none_gross', 'grosse_none', 'none'],
                15: ['dezime_klein', 'kleine_dezime', 'dezime'],
                16: ['dezime_gross', 'grosse_dezime', 'dezime'],
                17: ['undezime'],
                18: ['undezime_ueberm', 'ueberm_undezime', 'tritonus_oktave'],
                19: ['duodezime'],
                20: ['tredezime_klein', 'kleine_tredezime', 'tredezime'],
                21: ['tredezime_gross', 'grosse_tredezime', 'tredezime'],
                22: ['quartdezime_klein', 'kleine_quartdezime', 'quartdezime'],
                23: ['quartdezime_gross', 'grosse_quartdezime', 'quartdezime'],
                24: ['doppeloktave', 'doppel_oktave']
            };
            
            for (let i = 0; i <= 24; i++) {
                const prefix = i.toString().padStart(2, '0');
                const possibleNames = intervalNames[i] || ['model'];
                
                for (const name of possibleNames) {
                    const filename = `${prefix}_${name}.glb`;
                    const testPath = `./3d-models/${setName}/${filename}`;
                    
                    try {
                        const response = await fetch(testPath, { method: 'HEAD' });
                        if (response.ok) {
                            currentSetModels[i] = filename;
                            console.log(`Set ${setName}: Intervall ${i} -> ${filename}`);
                            break;
                        }
                    } catch (e) {
                        // Ignorieren
                    }
                }
            }
            
            console.log(`Set ${setName} geladen:`, currentSetModels);
        }
        
        // Modell f√ºr Intervall laden (ber√ºcksichtigt aktuelles Set)
        function getModelPathForInterval(semitones) {
            // Begrenze auf 0-24
            const clampedSemitones = Math.max(0, Math.min(24, semitones));
            
            if (currentModelSet && Object.keys(currentSetModels).length > 0) {
                // Set-Modus: Dateinummer = Halbt√∂ne
                if (currentSetModels[clampedSemitones]) {
                    return `${currentModelSet}/${currentSetModels[clampedSemitones]}`;
                }
                // Fallback auf Oktav-√Ñquivalent wenn >12 nicht vorhanden
                if (clampedSemitones > 12) {
                    const reduced = clampedSemitones % 12 || 12;
                    if (currentSetModels[reduced]) {
                        return `${currentModelSet}/${currentSetModels[reduced]}`;
                    }
                }
                // Fallback auf Prime
                if (currentSetModels[0]) {
                    return `${currentModelSet}/${currentSetModels[0]}`;
                }
            }
            
            // Legacy-Modus: Fallback auf set_01 wenn verf√ºgbar
            // Da die Legacy-Dateien im Root nicht mehr existieren,
            // verwenden wir set_01 als Default
            const defaultSetName = 'set_01';
            const intervalNames = {
                0: '00_prime', 1: '01_sekunde_klein', 2: '02_sekunde_gross',
                3: '03_terz_klein', 4: '04_terz_gross', 5: '05_quarte',
                6: '06_tritonus', 7: '07_quinte', 8: '08_sexte_klein',
                9: '09_sexte_gross', 10: '10_septime_klein', 11: '11_septime_gross',
                12: '12_oktave', 13: '13_none_klein', 14: '14_none_gross',
                15: '15_dezime_klein', 16: '16_dezime_gross', 17: '17_undezime',
                18: '18_undezime_ueberm', 19: '19_duodezime', 20: '20_tredezime_klein',
                21: '21_tredezime_gross', 22: '22_quartdezime_klein', 23: '23_quartdezime_gross',
                24: '24_doppeloktave'
            };
            const fallbackName = intervalNames[clampedSemitones] || intervalNames[0];
            return `${defaultSetName}/${fallbackName}.glb`;
        }
        
        // Morphing
        let morphingEnabled = true;
        let morphDuration = 500;
        let morphingInProgress = false;
        let morphStartTime = 0;
        let morphIncomingModel = null;
        let morphOutgoingModel = null;
        
        // Effekte - Original-Geometrien und Material-Farben Maps (hier fr√ºh definiert f√ºr prepareModel)
        let originalGeometries = new Map();
        let originalMaterialColors = new Map(); // Speichert { color: hex, emissive: hex } pro Material-UUID
        
        // === SCENE CLEANUP FUNKTIONEN ===
        // Bereinigt alte Eintr√§ge aus den Maps f√ºr ein bestimmtes Modell
        function cleanupModelMaps(model) {
            if (!model) return;
            const uuidsToRemove = [];
            model.traverse((child) => {
                if (child.isMesh) {
                    uuidsToRemove.push(child.uuid);
                }
            });
            uuidsToRemove.forEach(uuid => {
                originalGeometries.delete(uuid);
                originalMaterialColors.delete(uuid);
            });
        }
        
        // Vollst√§ndige Scene-Bereinigung - entfernt alle Modelle au√üer Lichter
        function cleanupScene() {
            const objectsToRemove = [];
            scene.traverse((obj) => {
                if (obj.isMesh || obj.isGroup) {
                    // Pr√ºfe ob es ein Modell ist (nicht Licht oder Kamera)
                    if (obj !== scene && !obj.isLight && !obj.isCamera) {
                        objectsToRemove.push(obj);
                    }
                }
            });
            
            // Nur Root-Level Objekte entfernen
            scene.children.forEach(child => {
                if (!child.isLight && !child.isCamera && child !== currentModel) {
                    if (child.isGroup || child.isMesh) {
                        scene.remove(child);
                        console.log('Cleanup: Entferne verwaistes Objekt', child.uuid);
                    }
                }
            });
            
            // Maps komplett leeren und f√ºr aktuelles Modell neu aufbauen
            originalGeometries.clear();
            originalMaterialColors.clear();
            
            if (currentModel) {
                storeOriginalGeometry(currentModel);
            }
            
            console.log('Scene cleanup abgeschlossen. Objekte in Scene:', scene.children.length);
        }
        
        // Periodischer Cleanup-Timer (alle 30 Sekunden)
        setInterval(() => {
            // Soft-Cleanup: Pr√ºfe auf verwaiste Objekte
            let orphanCount = 0;
            scene.children.forEach(child => {
                if (!child.isLight && !child.isCamera && 
                    child !== currentModel && 
                    child !== morphOutgoingModel && 
                    child !== morphIncomingModel) {
                    if (child.isGroup || child.isMesh) {
                        scene.remove(child);
                        orphanCount++;
                    }
                }
            });
            if (orphanCount > 0) {
                console.log(`Auto-Cleanup: ${orphanCount} verwaiste Objekte entfernt`);
            }
        }, 30000);
        
        async function loadModel(filenameOrSemitones) {
            let path;
            
            // Wenn eine Zahl √ºbergeben wird, ist es ein Intervall in Halbt√∂nen
            if (typeof filenameOrSemitones === 'number') {
                const modelPath = getModelPathForInterval(filenameOrSemitones);
                path = `./3d-models/${modelPath}`;
            } else {
                // Direkter Dateiname (Legacy)
                path = `./3d-models/${filenameOrSemitones}`;
            }
            
            // Wenn Morphing l√§uft, warte nicht - breche altes ab und starte neues
            if (morphingInProgress) {
                // Cleanup altes Morphing - Maps ZUERST bereinigen
                if (morphOutgoingModel) {
                    cleanupModelMaps(morphOutgoingModel);
                    scene.remove(morphOutgoingModel);
                }
                if (morphIncomingModel) {
                    currentModel = morphIncomingModel;
                    currentModel.traverse((child) => {
                        if (child.isMesh && child.material) {
                            child.material.opacity = 1;
                        }
                    });
                    currentModel.scale.set(currentScale, currentScale, currentScale);
                }
                morphingInProgress = false;
                morphOutgoingModel = null;
                morphIncomingModel = null;
            }
            
            let newModel;
            
            // Cache-Key ist der vollst√§ndige Pfad
            const cacheKey = path;
            
            if (modelCache[cacheKey]) {
                newModel = modelCache[cacheKey].clone();
            } else {
                newModel = await new Promise((resolve, reject) => {
                    loader.load(path, (gltf) => {
                        modelCache[cacheKey] = gltf.scene;
                        resolve(gltf.scene.clone());
                    }, undefined, (error) => {
                        console.warn(`Modell ${path} nicht gefunden`);
                        reject(error);
                    });
                });
            }
            
            // Bereite neues Modell vor
            prepareModel(newModel);
            
            if (morphingEnabled && currentModel) {
                // Starte Morphing-Transition
                startMorphTransition(currentModel, newModel);
            } else {
                // Sofortiger Wechsel - Maps des alten Modells bereinigen
                if (currentModel) {
                    cleanupModelMaps(currentModel);
                    scene.remove(currentModel);
                }
                currentModel = newModel;
                modelMaterials = [];
                currentModel.traverse((child) => {
                    if (child.isMesh && child.material) {
                        modelMaterials.push(child.material);
                    }
                });
                // Neue Original-Daten speichern
                storeOriginalGeometry(currentModel);
                scene.add(currentModel);
            }
        }
        
        function prepareModel(model) {
            model.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material = child.material.clone();
                    child.material.transparent = true;
                    child.material.opacity = 1;
                    // Standard-Farbe setzen (Clara C = Rot)
                    child.material.color = new THREE.Color(0xff3333);
                    child.material.emissive = new THREE.Color(0x661111);
                }
            });
            model.scale.set(currentScale, currentScale, currentScale);
            
            // Geometrien f√ºr Effekte speichern
            model.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    const posAttr = child.geometry.getAttribute('position');
                    if (posAttr) {
                        originalGeometries.set(child.uuid, posAttr.array.slice());
                    }
                }
            });
            
            // Wenn bereits eine Analyse vorhanden, Farben anwenden
            setTimeout(() => {
                if (typeof refreshVisuals === 'function') {
                    refreshVisuals();
                }
            }, 100);
        }
        
        function startMorphTransition(oldModel, newModel) {
            morphingInProgress = true;
            morphStartTime = performance.now();
            morphOutgoingModel = oldModel;
            morphIncomingModel = newModel;
            
            // Setze incoming Model auf unsichtbar und klein
            morphIncomingModel.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material.opacity = 0;
                }
            });
            morphIncomingModel.scale.set(0.01, 0.01, 0.01);
            scene.add(morphIncomingModel);
        }
        
        function updateMorphTransition() {
            if (!morphingInProgress) return;
            
            const elapsed = performance.now() - morphStartTime;
            const progress = Math.min(1, elapsed / morphDuration);
            
            // Easing function (ease-in-out)
            const eased = progress < 0.5 
                ? 2 * progress * progress 
                : 1 - Math.pow(-2 * progress + 2, 2) / 2;
            
            // Outgoing: fade out + shrink
            if (morphOutgoingModel) {
                const outScale = currentScale * (1 - eased * 0.3);
                morphOutgoingModel.scale.set(outScale, outScale, outScale);
                morphOutgoingModel.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.opacity = 1 - eased;
                    }
                });
            }
            
            // Incoming: fade in + grow
            if (morphIncomingModel) {
                const inScale = currentScale * (0.7 + eased * 0.3);
                morphIncomingModel.scale.set(inScale, inScale, inScale);
                morphIncomingModel.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.opacity = eased;
                    }
                });
            }
            
            // Transition complete
            if (progress >= 1) {
                // WICHTIG: Maps des alten Modells bereinigen BEVOR es entfernt wird
                if (morphOutgoingModel) {
                    cleanupModelMaps(morphOutgoingModel);
                    scene.remove(morphOutgoingModel);
                }
                
                currentModel = morphIncomingModel;
                modelMaterials = [];
                currentModel.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.opacity = 1;
                        modelMaterials.push(child.material);
                    }
                });
                currentModel.scale.set(currentScale, currentScale, currentScale);
                
                // Neue Original-Daten f√ºr das jetzt aktive Modell speichern
                storeOriginalGeometry(currentModel);
                
                morphOutgoingModel = null;
                morphIncomingModel = null;
                morphingInProgress = false;
            }
        }
        
        // Model Sets erkennen und dann erstes Modell laden
        async function initializeModels() {
            await detectModelSets(false);
            
            // Wenn Sets gefunden wurden, automatisch set_01 ausw√§hlen (oder erstes verf√ºgbares)
            if (availableModelSets.length > 0) {
                // Bevorzuge set_01, sonst erstes Set
                const preferredSet = availableModelSets.includes('set_01') ? 'set_01' : availableModelSets[0];
                currentModelSet = preferredSet;
                modelSetSelect.value = preferredSet;
                await loadSetModels(preferredSet);
                console.log(`Automatisch Set gew√§hlt: ${preferredSet}`);
                
                // Lade erstes Modell aus dem Set (Prime = 0)
                try {
                    await loadModel(0);
                    console.log('Erstes Modell geladen');
                } catch (err) {
                    console.log('Konnte erstes Modell aus Set nicht laden:', err);
                }
            } else {
                // Legacy-Modus: Lade Prime aus set_01 direkt
                console.log('Keine Sets gefunden, versuche set_01 als Fallback');
                loadModel('set_01/00_prime.glb').catch(() => {
                    console.log('Starte ohne Modell');
                });
            }
        }
        
        initializeModels();
        
        // Model Set Dropdown Event-Handler
        document.getElementById('modelSetSelect').addEventListener('change', async (e) => {
            const newSet = e.target.value;
            
            // Status anzeigen
            modelSetStatus.textContent = newSet ? `Lade ${newSet}...` : 'Lade Legacy...';
            modelSetStatus.style.color = '#ff0';
            
            // Set wechseln
            currentModelSet = newSet;
            modelCache = {}; // Cache leeren bei Set-Wechsel
            currentSetModels = {}; // Mapping zur√ºcksetzen
            
            if (newSet) {
                // Lade Modell-Mapping f√ºr neues Set
                await loadSetModels(newSet);
                
                const modelCount = Object.keys(currentSetModels).length;
                modelSetStatus.textContent = `${modelCount} Modelle geladen`;
                modelSetStatus.style.color = modelCount > 0 ? '#4f4' : '#f66';
            } else {
                modelSetStatus.textContent = 'Legacy-Modus';
                modelSetStatus.style.color = '#666';
            }
            
            // Aktuelles Modell neu laden mit neuem Set
            let targetInterval = 0; // Default: Prime
            
            if (lastAnalysis && lastAnalysis.intervals && lastAnalysis.intervals.length > 0) {
                targetInterval = lastAnalysis.intervals[0].semitones;
            }
            
            try {
                await loadModel(targetInterval);
                setTimeout(() => { modelSetStatus.textContent = ''; }, 2000);
            } catch (err) {
                console.error('Fehler beim Laden:', err);
                modelSetStatus.textContent = 'Ladefehler!';
                modelSetStatus.style.color = '#f66';
            }
        });

        // ============================================
        // VISUAL EFFECTS
        // ============================================
        
        let activeEffects = new Set(); // Multiple Effekte m√∂glich
        // Individuelle Intensit√§ten pro Effekt
        let effectIntensities = {
            glitch: 0.5,
            pulse: 0.5,
            edge: 0.5,
            explode: 0.5,
            particles: 0.5,
            trails: 0.7
        };
        let gainLinked = false;
        let currentGainLevel = 0; // 0-1 basierend auf Audio-Level
        let audioScaleEnabled = false;
        let audioScaleAmount = 0.3; // 0-1
        // wireframeWidth entfernt - Edge Detection hat eigene Glow-Einstellung
        // originalGeometries ist oben bei MODEL MANAGEMENT definiert
        let effectTime = 0;
        
        // Original-Geometrien und Material-Farben speichern
        function storeOriginalGeometry(model) {
            model.traverse((child) => {
                if (child.isMesh) {
                    // Geometrie speichern
                    if (child.geometry) {
                        const posAttr = child.geometry.getAttribute('position');
                        if (posAttr) {
                            originalGeometries.set(child.uuid, posAttr.array.slice());
                        }
                    }
                    // Material-Farben speichern (f√ºr Effekt-Reset)
                    if (child.material) {
                        originalMaterialColors.set(child.uuid, {
                            color: child.material.color.getHex(),
                            emissive: child.material.emissive ? child.material.emissive.getHex() : 0x000000
                        });
                    }
                }
            });
        }
        
        // Geometrie und Material-Farben zur√ºcksetzen
        function resetGeometry(model) {
            model.traverse((child) => {
                if (child.isMesh) {
                    // Geometrie zur√ºcksetzen
                    if (child.geometry) {
                        const original = originalGeometries.get(child.uuid);
                        if (original) {
                            const posAttr = child.geometry.getAttribute('position');
                            // Kopiere Original-Daten zur√ºck
                            posAttr.array.set(original);
                            // WICHTIG: Buffer explizit als dirty markieren
                            posAttr.needsUpdate = true;
                            // Bounding-Volumes neu berechnen
                            child.geometry.computeBoundingSphere();
                            child.geometry.computeBoundingBox();
                        }
                    }
                    // Material zur√ºcksetzen
                    if (child.material) {
                        child.material.wireframe = false;
                        child.material.opacity = 1;
                        child.material.needsUpdate = true; // Material als dirty markieren
                        // Farben zur√ºcksetzen
                        const originalColors = originalMaterialColors.get(child.uuid);
                        if (originalColors) {
                            child.material.color.setHex(originalColors.color);
                            if (child.material.emissive) {
                                child.material.emissive.setHex(originalColors.emissive);
                            }
                        }
                    }
                }
            });
        }
        
        // Effekte anwenden (mehrere gleichzeitig m√∂glich)
        function applyEffect(model, deltaTime) {
            if (!model) return;
            
            effectTime += deltaTime;
            
            // effectTime periodisch zur√ºcksetzen um numerische Probleme zu vermeiden
            // (bei langer Laufzeit k√∂nnen sehr gro√üe Werte Probleme verursachen)
            if (effectTime > 10000) {
                effectTime = effectTime % 10000;
            }
            
            // Wenn keine Effekte aktiv, stelle sicher dass alles zur√ºckgesetzt ist
            if (activeEffects.size === 0) {
                model.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.wireframe = false;
                    }
                });
                // Edge-Effekt deaktivieren
                edgePass.enabled = false;
                return;
            }
            
            // Edge-Effekt Status aktualisieren
            edgePass.enabled = activeEffects.has('edge');
            if (activeEffects.has('edge')) {
                edgePass.uniforms.edgeStrength.value = effectIntensities.edge * 3.0;
                edgePass.uniforms.edgeGlow.value = edgeGlow;
            }
            
            model.traverse((child) => {
                if (!child.isMesh) return;
                
                const geometry = child.geometry;
                const material = child.material;
                
                // WICHTIG: Material-Eigenschaften IMMER zur√ºcksetzen, unabh√§ngig von Geometrie
                if (material) {
                    // Wireframe nur true wenn wireframe-Effekt aktiv ist
                    material.wireframe = activeEffects.has('wireframe');
                    
                    // KRITISCH: Emissive-Farbe auf Original zur√ºcksetzen vor Effekt-Anwendung
                    // Dies verhindert Farb-Akkumulation bei Glitch, Pulse und Explode
                    const originalColors = originalMaterialColors.get(child.uuid);
                    if (originalColors && material.emissive) {
                        material.emissive.setHex(originalColors.emissive);
                    }
                }
                
                const original = originalGeometries.get(child.uuid);
                
                // F√ºr Geometrie-Effekte brauchen wir die Original-Daten
                // Falls keine vorhanden, versuche sie jetzt zu speichern
                if (geometry && !original) {
                    const posAttr = geometry.getAttribute('position');
                    if (posAttr) {
                        originalGeometries.set(child.uuid, posAttr.array.slice());
                        // Material-Farben auch speichern falls nicht vorhanden
                        if (material && !originalMaterialColors.has(child.uuid)) {
                            originalMaterialColors.set(child.uuid, {
                                color: material.color.getHex(),
                                emissive: material.emissive ? material.emissive.getHex() : 0x000000
                            });
                        }
                    }
                }
                
                // Erneut pr√ºfen nach m√∂glicher Speicherung
                const originalData = originalGeometries.get(child.uuid);
                if (!geometry || !originalData) return;
                
                const posAttr = geometry.getAttribute('position');
                const positions = posAttr.array;
                
                // Zuerst Positionen auf Original zur√ºcksetzen
                for (let i = 0; i < positions.length; i++) {
                    positions[i] = originalData[i];
                }
                
                // Offset-Akkumulatoren f√ºr additive Effekte
                const offsets = new Float32Array(positions.length);
                let scaleFactor = 1.0;
                
                // Alle aktiven Effekte anwenden
                for (const effect of activeEffects) {
                    switch (effect) {
                        case 'glitch': {
                            // Glitch: Zuf√§llige Verschiebungen + Farbflackern
                            const glitchInt = effectIntensities.glitch;
                            for (let i = 0; i < positions.length; i += 3) {
                                if (Math.random() < 0.1 * glitchInt) {
                                    offsets[i] += (Math.random() - 0.5) * glitchInt * 0.5;
                                    offsets[i + 1] += (Math.random() - 0.5) * glitchInt * 0.5;
                                    offsets[i + 2] += (Math.random() - 0.5) * glitchInt * 0.5;
                                }
                            }
                            // Farb-Glitch
                            if (material && Math.random() < 0.1 * glitchInt) {
                                material.emissive.setHex(Math.random() > 0.5 ? 0xff0066 : 0x00ffff);
                            }
                            break;
                        }
                            
                        case 'pulse': {
                            // Pulse: Sinusf√∂rmiges Pulsieren
                            const pulseInt = effectIntensities.pulse;
                            const pulse = Math.sin(effectTime * 4) * pulseInt * 0.3;
                            scaleFactor *= (1 + pulse);
                            // Emissive pulsiert mit
                            if (material) {
                                const glow = 0.2 + Math.sin(effectTime * 4) * 0.3 * pulseInt;
                                material.emissive.multiplyScalar(1 + glow * 0.5);
                            }
                            break;
                        }
                            
                        case 'edge': {
                            // Edge Detection ist ein Post-Processing Effekt
                            // Er wird √ºber edgePass.enabled gesteuert (oben bereits gesetzt)
                            // Hier nur minimale Geometrie-Animation f√ºr visuelles Feedback
                            const edgeInt = effectIntensities.edge;
                            // Sehr subtiles Zittern der Vertices f√ºr mehr "Lebendigkeit"
                            for (let i = 0; i < positions.length; i += 3) {
                                offsets[i] += Math.sin(effectTime * 15 + i) * 0.005 * edgeInt;
                                offsets[i + 1] += Math.cos(effectTime * 15 + i) * 0.005 * edgeInt;
                            }
                            break;
                        }
                            
                        case 'explode': {
                            // Explode: Vertices bewegen sich vom Zentrum weg
                            const explodeInt = effectIntensities.explode;
                            const explodeAmount = explodeInt * (0.5 + Math.sin(effectTime * 2) * 0.5);
                            for (let i = 0; i < positions.length; i += 3) {
                                const x = originalData[i];
                                const y = originalData[i + 1];
                                const z = originalData[i + 2];
                                const expandFactor = explodeAmount * 0.5;
                                offsets[i] += x * expandFactor + Math.sin(effectTime * 3 + i) * 0.1 * explodeInt;
                                offsets[i + 1] += y * expandFactor + Math.cos(effectTime * 3 + i) * 0.1 * explodeInt;
                                offsets[i + 2] += z * expandFactor + Math.sin(effectTime * 2 + i) * 0.1 * explodeInt;
                            }
                            // Farbexplosion
                            if (material) {
                                const hue = (effectTime * 0.2) % 1;
                                material.emissive.offsetHSL(hue * 0.1, 0, explodeInt * 0.2);
                            }
                            break;
                        }
                    }
                }
                
                // Offsets und Skalierung anwenden
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] = originalData[i] * scaleFactor + offsets[i];
                    positions[i + 1] = originalData[i + 1] * scaleFactor + offsets[i + 1];
                    positions[i + 2] = originalData[i + 2] * scaleFactor + offsets[i + 2];
                }
                
                // WICHTIG: Buffer explizit als dirty markieren
                posAttr.needsUpdate = true;
                
                // Bounding-Sphere/-Box invalidieren f√ºr korrekte Culling
                if (geometry.boundingSphere) geometry.computeBoundingSphere();
                if (geometry.boundingBox) geometry.computeBoundingBox();
            });
        }
        
        // Effekt togglen (mehrere gleichzeitig m√∂glich)
        function toggleEffect(effect) {
            if (activeEffects.has(effect)) {
                activeEffects.delete(effect);
            } else {
                activeEffects.add(effect);
            }
            
            // Spezielle Behandlung f√ºr Particles
            if (effect === 'particles') {
                particlesEnabled = activeEffects.has('particles');
                if (particleSystem) {
                    particleSystem.visible = particlesEnabled;
                }
            }
            
            // Spezielle Behandlung f√ºr Trails
            if (effect === 'trails') {
                trailsEnabled = activeEffects.has('trails');
                afterimagePass.enabled = trailsEnabled;
            }
            
            // Spezielle Behandlung f√ºr Edge (Post-Processing)
            if (effect === 'edge') {
                edgePass.enabled = activeEffects.has('edge');
            }
            
            // Geometrie zur√ºcksetzen wenn keine Effekte mehr aktiv
            if (activeEffects.size === 0 && currentModel) {
                resetGeometry(currentModel);
                modelMaterials.forEach(mat => {
                    mat.wireframe = false;
                    mat.opacity = 1;
                    mat.transparent = true;
                });
                // Alle Post-Processing Effekte sicherheitshalber deaktivieren
                edgePass.enabled = false;
                afterimagePass.enabled = false;
            }
            
            // Original-Geometrien speichern wenn Effekte aktiv
            if (activeEffects.size > 0 && currentModel) {
                storeOriginalGeometry(currentModel);
            }
            
            // Slider-Container f√ºr den Effekt ein-/ausblenden
            const sliderContainer = document.getElementById(`${effect}SliderContainer`);
            if (sliderContainer) {
                sliderContainer.classList.toggle('visible', activeEffects.has(effect));
            }
            
            // UI updaten
            document.querySelectorAll('.effect-btn').forEach(btn => {
                btn.classList.toggle('active', activeEffects.has(btn.dataset.effect));
            });
            
            // Farben neu anwenden
            refreshVisuals();
        }
        
        // Alle Effekte deaktivieren
        function clearAllEffects() {
            activeEffects.clear();
            // Edge-Effekt explizit deaktivieren
            edgePass.enabled = false;
            // Trails deaktivieren
            afterimagePass.enabled = false;
            trailsEnabled = false;
            // Partikel deaktivieren
            particlesEnabled = false;
            if (particleSystem) {
                particleSystem.visible = false;
            }
            if (currentModel) {
                resetGeometry(currentModel);
                modelMaterials.forEach(mat => {
                    mat.wireframe = false;
                    mat.opacity = 1;
                    mat.transparent = true;
                });
            }
            document.querySelectorAll('.effect-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            // Alle Slider-Container ausblenden
            document.querySelectorAll('.effect-slider').forEach(container => {
                container.classList.remove('visible');
            });
            refreshVisuals();
        }
        
        // Event-Handler f√ºr Effekt-Buttons (Toggle)
        document.querySelectorAll('.effect-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                toggleEffect(btn.dataset.effect);
            });
        });
        
        // Individuelle Intensit√§ts-Slider f√ºr jeden Effekt
        ['glitch', 'pulse', 'edge', 'explode'].forEach(effect => {
            const slider = document.getElementById(`${effect}Intensity`);
            const valueDisplay = document.getElementById(`${effect}IntensityValue`);
            if (slider && valueDisplay) {
                slider.addEventListener('input', (e) => {
                    effectIntensities[effect] = parseInt(e.target.value) / 100;
                    valueDisplay.textContent = e.target.value + '%';
                    // Edge-Effekt live aktualisieren
                    if (effect === 'edge' && edgePass.enabled) {
                        edgePass.uniforms.edgeStrength.value = effectIntensities.edge * 3.0;
                    }
                });
            }
        });
        
        // Edge Glow Slider
        document.getElementById('edgeGlow').addEventListener('input', (e) => {
            edgeGlow = parseFloat(e.target.value) / 100;
            document.getElementById('edgeGlowValue').textContent = e.target.value + '%';
            // Live aktualisieren wenn Edge aktiv
            if (edgePass.enabled) {
                edgePass.uniforms.edgeGlow.value = edgeGlow;
            }
        });
        
        // Partikel Slider
        document.getElementById('particlesIntensity').addEventListener('input', (e) => {
            particlesIntensity = parseInt(e.target.value) / 100;
            effectIntensities.particles = particlesIntensity;
            document.getElementById('particlesIntensityValue').textContent = e.target.value + '%';
        });
        
        document.getElementById('particlesSize').addEventListener('input', (e) => {
            particlesSize = parseInt(e.target.value) / 100;
            document.getElementById('particlesSizeValue').textContent = e.target.value + '%';
        });
        
        // Trails Slider
        document.getElementById('trailsIntensity').addEventListener('input', (e) => {
            const intensity = parseInt(e.target.value) / 100;
            effectIntensities.trails = intensity;
            document.getElementById('trailsIntensityValue').textContent = e.target.value + '%';
            setTrailsIntensity(intensity);
        });
        
        // Initial Trails-Intensit√§t setzen
        setTrailsIntensity(0.7);
        
        // Audio-Skalierung
        const audioScaleCheckbox = document.getElementById('audioScaleEnabled');
        const audioScaleSlider = document.getElementById('audioScaleAmount');
        const audioScaleControl = document.getElementById('audioScaleControl');
        
        audioScaleCheckbox.addEventListener('change', (e) => {
            audioScaleEnabled = e.target.checked;
            audioScaleSlider.disabled = !audioScaleEnabled;
            audioScaleControl.style.opacity = audioScaleEnabled ? '1' : '0.5';
        });
        
        audioScaleSlider.addEventListener('input', (e) => {
            audioScaleAmount = parseInt(e.target.value) / 100;
            document.getElementById('audioScaleAmountValue').textContent = e.target.value + '%';
        });
        
        // Audio-Helligkeit
        document.getElementById('gainLinked').addEventListener('change', (e) => {
            gainLinked = e.target.checked;
            if (!gainLinked) {
                // Reset zu voller Helligkeit wenn deaktiviert
                currentGainLevel = 1;
            }
            // Sofort aktualisieren
            refreshVisuals();
        });
        
        document.getElementById('blackLevel').addEventListener('input', (e) => {
            const level = parseInt(e.target.value);
            document.getElementById('blackLevelValue').textContent = level;
            // RGB-Wert setzen (0-50 -> 0x000000 - 0x323232)
            const hex = (level << 16) | (level << 8) | level;
            renderer.setClearColor(hex);
        });
        
        // Reset All Button - L√∂st vollst√§ndige Bereinigung aus
        document.getElementById('resetAllBtn').addEventListener('click', () => {
            console.log('=== RESET ALL gestartet ===');
            
            // 1. Alle Effekte deaktivieren
            clearAllEffects();
            
            // 2. Morphing abbrechen falls aktiv
            if (morphingInProgress) {
                if (morphOutgoingModel) {
                    cleanupModelMaps(morphOutgoingModel);
                    scene.remove(morphOutgoingModel);
                }
                if (morphIncomingModel) {
                    cleanupModelMaps(morphIncomingModel);
                    scene.remove(morphIncomingModel);
                }
                morphOutgoingModel = null;
                morphIncomingModel = null;
                morphingInProgress = false;
            }
            
            // 3. Scene komplett bereinigen
            cleanupScene();
            
            // 4. effectTime zur√ºcksetzen
            effectTime = 0;
            
            // 5. Wenn aktuelles Modell existiert, Geometrie vollst√§ndig zur√ºcksetzen
            if (currentModel) {
                resetGeometry(currentModel);
                // Alle Materialien zur√ºcksetzen
                modelMaterials.forEach(mat => {
                    mat.wireframe = false;
                    mat.opacity = 1;
                    mat.transparent = true;
                });
            }
            
            // 6. Farben neu anwenden
            refreshVisuals();
            
            console.log('=== RESET ALL abgeschlossen ===');
            console.log('Scene children:', scene.children.length);
            console.log('originalGeometries size:', originalGeometries.size);
            console.log('originalMaterialColors size:', originalMaterialColors.size);
        });

        // ============================================
        // AUDIO CHAIN (EQ + Gain)
        // ============================================
        
        let audioContext, analyser;
        let masterGainNode = null;
        let eqNodes = {};
        let sensitivity = 0.05;
        let reactionSmoothing = 0.3; // 0 = sofort, 1 = sehr langsam (Standard: 0.3 f√ºr 70%)
        
        // Audio Passthrough
        let passthroughEnabled = false;
        let passthroughGainNode = null;
        let passthroughDestination = null;
        let passthroughAudioElement = null;
        let currentOutputDeviceId = '';
        
        function createAudioChain(stream) {
            audioContext = new AudioContext();
            
            const source = audioContext.createMediaStreamSource(stream);
            
            // 5-Band Parametric EQ
            const eqConfig = {
                low:     { freq: 100,  type: 'lowshelf' },
                lowMid:  { freq: 400,  type: 'peaking', Q: 1.5 },
                mid:     { freq: 1000, type: 'peaking', Q: 1.5 },
                highMid: { freq: 2500, type: 'peaking', Q: 1.5 },
                high:    { freq: 6000, type: 'highshelf' }
            };
            
            let lastNode = source;
            
            Object.entries(eqConfig).forEach(([name, config]) => {
                const eq = audioContext.createBiquadFilter();
                eq.type = config.type;
                eq.frequency.value = config.freq;
                if (config.Q) eq.Q.value = config.Q;
                eq.gain.value = 0;
                
                lastNode.connect(eq);
                lastNode = eq;
                eqNodes[name] = eq;
            });
            
            // Master Gain
            masterGainNode = audioContext.createGain();
            masterGainNode.gain.value = 1;
            lastNode.connect(masterGainNode);
            
            // Analyser
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 8192;
            analyser.smoothingTimeConstant = reactionSmoothing; // Dynamisch einstellbar
            masterGainNode.connect(analyser);
            
            // Audio Passthrough Setup
            passthroughGainNode = audioContext.createGain();
            passthroughGainNode.gain.value = 0; // Startet stumm
            masterGainNode.connect(passthroughGainNode);
            
            // MediaStreamDestination f√ºr Audio-Output
            passthroughDestination = audioContext.createMediaStreamDestination();
            passthroughGainNode.connect(passthroughDestination);
            
            // Audio-Element f√ºr Output-Ger√§t-Auswahl
            if (!passthroughAudioElement) {
                passthroughAudioElement = document.createElement('audio');
                passthroughAudioElement.autoplay = true;
                document.body.appendChild(passthroughAudioElement);
            }
            passthroughAudioElement.srcObject = passthroughDestination.stream;
            
            // Ausgabeger√§t setzen wenn bereits gew√§hlt
            if (currentOutputDeviceId && passthroughAudioElement.setSinkId) {
                passthroughAudioElement.setSinkId(currentOutputDeviceId).catch(e => {
                    console.warn('Konnte Ausgabeger√§t nicht setzen:', e);
                });
            }
            
            return audioContext;
        }
        
        function dbToGain(db) {
            return Math.pow(10, db / 20);
        }

        // ============================================
        // BEAT DETECTION
        // ============================================
        
        let beatSensitivity = 0.5;
        let beatMinBpm = 60;
        let beatMaxBpm = 180;
        let beatFlashEnabled = true;
        let beatPulseEnabled = false;
        let beatRotationEnabled = false;
        let baseRotationSpeed = 0.002; // Basis-Rotationsgeschwindigkeit (0 = still, 0.01 = schnell)
        
        // Beat Detection State
        let beatHistory = [];
        let beatTimes = [];
        let lastBeatTime = 0;
        let currentBpm = 0;
        let energyHistory = [];
        const ENERGY_HISTORY_SIZE = 43; // ~1 Sekunde bei 60fps
        let beatPulseAmount = 0;
        let beatRotationAmount = 0; // F√ºr Beat-gesteuerte Rotation
        
        const beatIndicator = document.getElementById('beatIndicator');
        const bpmValue = document.getElementById('bpmValue');
        
        function detectBeat(analyser) {
            if (!analyser) return false;
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);
            
            // Berechne Energie (gewichtet auf Bass/Kick-Frequenzen 60-150Hz)
            let energy = 0;
            const sampleRate = analyser.context.sampleRate;
            const binSize = sampleRate / analyser.fftSize;
            const lowBin = Math.floor(60 / binSize);
            const highBin = Math.floor(150 / binSize);
            
            for (let i = lowBin; i < highBin && i < bufferLength; i++) {
                energy += dataArray[i] * dataArray[i];
            }
            energy = Math.sqrt(energy / (highBin - lowBin));
            
            // Energie-Historie aktualisieren
            energyHistory.push(energy);
            if (energyHistory.length > ENERGY_HISTORY_SIZE) {
                energyHistory.shift();
            }
            
            // Durchschnitt und Varianz berechnen
            const avgEnergy = energyHistory.reduce((a, b) => a + b, 0) / energyHistory.length;
            const variance = energyHistory.reduce((a, b) => a + (b - avgEnergy) ** 2, 0) / energyHistory.length;
            const threshold = avgEnergy + Math.sqrt(variance) * (2 - beatSensitivity * 1.5);
            
            // Mindestabstand zwischen Beats (basierend auf Max BPM)
            const minBeatInterval = 60000 / beatMaxBpm;
            const now = performance.now();
            
            // Beat erkannt?
            if (energy > threshold && energy > 30 && (now - lastBeatTime) > minBeatInterval) {
                lastBeatTime = now;
                beatTimes.push(now);
                
                // Alte Beat-Zeiten entfernen (√§lter als 4 Sekunden)
                beatTimes = beatTimes.filter(t => now - t < 4000);
                
                // BPM berechnen
                if (beatTimes.length >= 4) {
                    const intervals = [];
                    for (let i = 1; i < beatTimes.length; i++) {
                        intervals.push(beatTimes[i] - beatTimes[i - 1]);
                    }
                    const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                    const calculatedBpm = Math.round(60000 / avgInterval);
                    
                    // Nur aktualisieren wenn im g√ºltigen Bereich
                    if (calculatedBpm >= beatMinBpm && calculatedBpm <= beatMaxBpm) {
                        currentBpm = calculatedBpm;
                        bpmValue.textContent = currentBpm + ' BPM';
                    }
                }
                
                return true;
            }
            
            return false;
        }
        
        function triggerBeatFlash() {
            if (beatFlashEnabled) {
                beatIndicator.classList.add('flash');
                setTimeout(() => beatIndicator.classList.remove('flash'), 100);
            }
            
            if (beatPulseEnabled) {
                beatPulseAmount = 1.0;
            }
            
            if (beatRotationEnabled) {
                beatRotationAmount = Math.PI / 4; // 45¬∞ Rotation pro Beat
            }
        }
        
        // Beat Detection UI Event Handlers
        document.getElementById('beatSensitivity').addEventListener('input', (e) => {
            beatSensitivity = parseInt(e.target.value) / 100;
            document.getElementById('beatSensitivityValue').textContent = e.target.value + '%';
        });
        
        document.getElementById('beatFlashEnabled').addEventListener('change', (e) => {
            beatFlashEnabled = e.target.checked;
        });
        
        document.getElementById('beatPulseEnabled').addEventListener('change', (e) => {
            beatPulseEnabled = e.target.checked;
        });
        
        document.getElementById('beatRotationEnabled').addEventListener('change', (e) => {
            beatRotationEnabled = e.target.checked;
        });
        
        document.getElementById('rotationSpeed').addEventListener('input', (e) => {
            const percent = parseInt(e.target.value);
            document.getElementById('rotationSpeedValue').textContent = percent + '%';
            // 0% = 0, 100% = 0.01 (sehr schnell)
            baseRotationSpeed = (percent / 100) * 0.01;
        });
        
        // ============================================
        // KAMERA EVENT HANDLERS
        // ============================================
        
        // Kamera Lock
        document.getElementById('cameraLocked').addEventListener('change', (e) => {
            cameraLocked = e.target.checked;
            controls.enabled = !cameraLocked && !autoOrbitEnabled;
        });
        
        // Kamera Reset
        document.getElementById('cameraResetBtn').addEventListener('click', () => {
            // Auto-Orbit deaktivieren falls aktiv
            if (autoOrbitEnabled) {
                toggleAutoOrbit();
            }
            resetCamera();
        });
        
        // Auto-Orbit Toggle
        document.getElementById('cameraOrbitBtn').addEventListener('click', () => {
            toggleAutoOrbit();
        });
        
        // FOV Slider
        document.getElementById('cameraFov').addEventListener('input', (e) => {
            const fov = parseInt(e.target.value);
            document.getElementById('cameraFovValue').textContent = fov + '¬∞';
            baseFov = fov;
            if (!fovAudioLinked) {
                camera.fov = fov;
                camera.updateProjectionMatrix();
            }
        });
        
        // FOV Audio Link
        document.getElementById('fovAudioLinked').addEventListener('change', (e) => {
            fovAudioLinked = e.target.checked;
            const slider = document.getElementById('fovAudioAmount');
            const control = document.getElementById('fovAudioControl');
            slider.disabled = !fovAudioLinked;
            control.style.opacity = fovAudioLinked ? '1' : '0.5';
            
            // Wenn deaktiviert, FOV auf Slider-Wert zur√ºcksetzen
            if (!fovAudioLinked) {
                camera.fov = baseFov;
                camera.updateProjectionMatrix();
            }
        });
        
        // FOV Audio Amount
        document.getElementById('fovAudioAmount').addEventListener('input', (e) => {
            fovAudioAmount = parseInt(e.target.value) / 100;
            document.getElementById('fovAudioAmountValue').textContent = e.target.value + '%';
        });
        
        // Blur Slider
        document.getElementById('cameraBlur').addEventListener('input', (e) => {
            const intensity = parseInt(e.target.value) / 100;
            document.getElementById('cameraBlurValue').textContent = e.target.value + '%';
            setBlurIntensity(intensity);
        });

        // ============================================
        // PITCH DETECTION ALGORITHMS
        // ============================================
        
        const PitchAlgorithms = {
            'hps': {
                name: 'HPS',
                description: 'Harmonic Product Spectrum: Beste Oberton-Unterdr√ºckung f√ºr polyphon.',
                type: 'poly'
            },
            'hps_whitened': {
                name: 'HPS+White',
                description: 'HPS mit spektraler Whitening. Gleichm√§√üigere Peaks.',
                type: 'poly'
            },
            'peak_simple': {
                name: 'Peak',
                description: 'Einfache Peak-Detection. Schnell aber Oberton-anf√§llig.',
                type: 'poly'
            },
            'autocorr': {
                name: 'Autocorr',
                description: 'Autokorrelation im Zeitbereich. Gut f√ºr monophone Signale.',
                type: 'mono'
            },
            'cepstrum': {
                name: 'Cepstrum',
                description: 'Cepstral Analysis. Trennt Quelle von Formanten.',
                type: 'mono'
            },
            'yin': {
                name: 'YIN',
                description: 'Sehr pr√§zise f√ºr monophone Signale.',
                type: 'mono'
            }
        };
        
        let activeAlgorithms = new Set(['hps_whitened']);
        let combineMode = 'union';
        
        // ============================================
        // MULTI-ALGORITHM PITCH DETECTOR
        // ============================================
        
        class PolyphonicPitchDetector {
            constructor(audioContext, analyser) {
                this.audioContext = audioContext;
                this.analyser = analyser;
                this.fftSize = analyser.fftSize;
                this.sampleRate = audioContext.sampleRate;
                this.frequencyData = new Float32Array(analyser.frequencyBinCount);
                this.timeData = new Float32Array(analyser.fftSize);
                
                // Hann Window vorberechnen
                this.hannWindow = new Float32Array(this.fftSize);
                for (let i = 0; i < this.fftSize; i++) {
                    this.hannWindow[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (this.fftSize - 1)));
                }
                
                // Temporal Smoothing Buffer
                this.noteHistory = [];
                this.historyLength = 2; // Reduziert f√ºr schnellere Reaktion (war 3)
                
                // HPS Einstellungen
                this.hpsHarmonics = 5;
            }
            
            freqToMidi(freq) {
                return 69 + 12 * Math.log2(freq / 440);
            }
            
            midiToFreq(midi) {
                return 440 * Math.pow(2, (midi - 69) / 12);
            }
            
            midiToNote(midi) {
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                const octave = Math.floor(midi / 12) - 1;
                const noteIndex = midi % 12;
                return {
                    name: noteNames[noteIndex],
                    octave: octave,
                    full: noteNames[noteIndex] + octave,
                    midi: midi,
                    isSharp: noteNames[noteIndex].includes('#')
                };
            }
            
            binToFreq(bin) {
                return bin * this.sampleRate / this.fftSize;
            }
            
            freqToBin(freq) {
                return freq * this.fftSize / this.sampleRate;
            }
            
            // Harmonic Product Spectrum - unterdr√ºckt Obert√∂ne
            computeHPS(magnitudes, minBin, maxBin) {
                const hpsLength = Math.floor(maxBin / this.hpsHarmonics);
                const hps = new Float32Array(hpsLength);
                
                for (let i = minBin; i < hpsLength; i++) {
                    let product = magnitudes[i];
                    for (let h = 2; h <= this.hpsHarmonics; h++) {
                        const harmonicBin = i * h;
                        if (harmonicBin < maxBin) {
                            product += magnitudes[harmonicBin]; // Sum statt Produkt (stabiler in dB)
                        }
                    }
                    hps[i] = product / this.hpsHarmonics;
                }
                
                return hps;
            }
            
            // Spektrale Whitening - normalisiert lokale Energie
            applyWhitening(magnitudes, windowSize = 50) {
                const whitened = new Float32Array(magnitudes.length);
                
                for (let i = 0; i < magnitudes.length; i++) {
                    const start = Math.max(0, i - windowSize);
                    const end = Math.min(magnitudes.length, i + windowSize);
                    
                    let localMean = 0;
                    for (let j = start; j < end; j++) {
                        localMean += magnitudes[j];
                    }
                    localMean /= (end - start);
                    
                    whitened[i] = magnitudes[i] - localMean;
                }
                
                return whitened;
            }
            
            // Verbesserte Peak Detection mit Parabolic Interpolation
            detectPeaksImproved(magnitudes, minBin, maxBin, threshold) {
                const peaks = [];
                
                // Finde lokale Maxima
                for (let i = minBin + 2; i < maxBin - 2; i++) {
                    const curr = magnitudes[i];
                    
                    // Muss h√∂her sein als 2 Nachbarn auf jeder Seite
                    if (curr > magnitudes[i-1] && curr > magnitudes[i+1] &&
                        curr > magnitudes[i-2] && curr > magnitudes[i+2] &&
                        curr > threshold) {
                        
                        // Parabolic Interpolation f√ºr Sub-Bin Genauigkeit
                        const alpha = magnitudes[i-1];
                        const beta = magnitudes[i];
                        const gamma = magnitudes[i+1];
                        
                        const delta = 0.5 * (alpha - gamma) / (alpha - 2*beta + gamma);
                        const interpolatedBin = i + delta;
                        const interpolatedMag = beta - 0.25 * (alpha - gamma) * delta;
                        
                        const freq = this.binToFreq(interpolatedBin);
                        
                        // Confidence basierend auf Peak-Sch√§rfe
                        const sharpness = beta - (alpha + gamma) / 2;
                        const confidence = Math.min(1, sharpness / 20);
                        
                        peaks.push({
                            frequency: freq,
                            magnitude: interpolatedMag,
                            bin: interpolatedBin,
                            confidence: confidence
                        });
                    }
                }
                
                // Sortiere nach Magnitude
                peaks.sort((a, b) => b.magnitude - a.magnitude);
                
                return peaks;
            }
            
            // Harmonische Gruppierung und Grundton-Extraktion
            extractFundamentals(peaks, maxNotes = 4) {
                if (peaks.length === 0) return [];
                
                const fundamentals = [];
                const usedPeaks = new Set();
                
                // Iteriere durch Peaks (st√§rkster zuerst)
                for (const peak of peaks) {
                    if (usedPeaks.has(peak)) continue;
                    if (fundamentals.length >= maxNotes) break;
                    
                    const freq = peak.frequency;
                    const midi = Math.round(this.freqToMidi(freq));
                    
                    // Pr√ºfe ob dieser Peak eine Harmonische eines bereits gefundenen Grundtons ist
                    let isHarmonic = false;
                    for (const fund of fundamentals) {
                        const ratio = freq / fund.frequency;
                        // Pr√ºfe Verh√§ltnisse 2, 3, 4, 5, 6
                        for (let h = 2; h <= 6; h++) {
                            if (Math.abs(ratio - h) < 0.08) {
                                isHarmonic = true;
                                // Erh√∂he Confidence des Grundtons
                                fund.confidence = Math.min(1, fund.confidence + 0.1);
                                break;
                            }
                        }
                        if (isHarmonic) break;
                    }
                    
                    // Pr√ºfe auch ob ein niedrigerer Peak der echte Grundton sein k√∂nnte
                    if (!isHarmonic) {
                        for (const otherPeak of peaks) {
                            if (otherPeak === peak || usedPeaks.has(otherPeak)) continue;
                            
                            const ratio = freq / otherPeak.frequency;
                            // Wenn dieser Peak ~2x, 3x etc. eines schw√§cheren Peaks ist
                            for (let h = 2; h <= 4; h++) {
                                if (Math.abs(ratio - h) < 0.06 && otherPeak.magnitude > peak.magnitude * 0.3) {
                                    // Der andere Peak k√∂nnte der echte Grundton sein
                                    isHarmonic = true;
                                    break;
                                }
                            }
                            if (isHarmonic) break;
                        }
                    }
                    
                    if (!isHarmonic && midi >= 36 && midi <= 96) {
                        fundamentals.push({
                            ...this.midiToNote(midi),
                            frequency: freq,
                            magnitude: peak.magnitude,
                            confidence: peak.confidence
                        });
                        usedPeaks.add(peak);
                    }
                }
                
                // Sortiere nach Tonh√∂he
                fundamentals.sort((a, b) => a.midi - b.midi);
                
                return fundamentals;
            }
            
            // Temporal Smoothing - stabilisiert Erkennung
            applyTemporalSmoothing(notes) {
                this.noteHistory.push(notes.map(n => n.midi));
                if (this.noteHistory.length > this.historyLength) {
                    this.noteHistory.shift();
                }
                
                // Bei nur einem Frame in History: alle Noten durchlassen
                if (this.noteHistory.length < 2) return notes;
                
                // Z√§hle wie oft jede Note in der History vorkommt
                const noteCounts = {};
                for (const frame of this.noteHistory) {
                    for (const midi of frame) {
                        noteCounts[midi] = (noteCounts[midi] || 0) + 1;
                    }
                }
                
                // Noten die mindestens einmal vorkommen durchlassen (schnellere Reaktion)
                // Nur komplett neue Noten die nur 1x vorkommen UND nicht im aktuellen Frame sind werden gefiltert
                return notes;
            }
            
            // Hauptmethode: Erkenne T√∂ne mit gew√§hlten Algorithmen
            detect() {
                this.analyser.getFloatFrequencyData(this.frequencyData);
                this.analyser.getFloatTimeDomainData(this.timeData);
                
                if (activeAlgorithms.size === 0) return [];
                
                // Sammle Ergebnisse aller aktiven Algorithmen
                const allResults = [];
                
                for (const algo of activeAlgorithms) {
                    let notes = [];
                    switch(algo) {
                        case 'hps':
                            notes = this.detectHPS(false);
                            break;
                        case 'hps_whitened':
                            notes = this.detectHPS(true);
                            break;
                        case 'peak_simple':
                            notes = this.detectSimplePeaks();
                            break;
                        case 'autocorr':
                            notes = this.detectAutocorrelation();
                            break;
                        case 'cepstrum':
                            notes = this.detectCepstrum();
                            break;
                        case 'yin':
                            notes = this.detectYIN();
                            break;
                    }
                    allResults.push({ algo, notes });
                }
                
                // Kombiniere Ergebnisse
                let combined = this.combineResults(allResults);
                
                // Temporal Smoothing
                combined = this.applyTemporalSmoothing(combined);
                
                return combined;
            }
            
            // Kombiniere Ergebnisse mehrerer Algorithmen
            combineResults(allResults) {
                if (allResults.length === 0) return [];
                if (allResults.length === 1) return allResults[0].notes;
                
                // Sammle alle MIDI-Noten mit ihren Votes und Confidences
                const noteVotes = {}; // midi -> { count, totalConfidence, bestNote }
                
                for (const { algo, notes } of allResults) {
                    for (const note of notes) {
                        if (!noteVotes[note.midi]) {
                            noteVotes[note.midi] = { count: 0, totalConfidence: 0, bestNote: note };
                        }
                        noteVotes[note.midi].count++;
                        noteVotes[note.midi].totalConfidence += (note.confidence || 0.5);
                        if ((note.confidence || 0.5) > (noteVotes[note.midi].bestNote.confidence || 0.5)) {
                            noteVotes[note.midi].bestNote = note;
                        }
                    }
                }
                
                const numAlgos = allResults.length;
                let result = [];
                
                switch(combineMode) {
                    case 'union':
                        // Alle erkannten T√∂ne
                        result = Object.values(noteVotes).map(v => ({
                            ...v.bestNote,
                            confidence: v.totalConfidence / numAlgos
                        }));
                        break;
                        
                    case 'intersection':
                        // Nur T√∂ne die von ALLEN erkannt wurden
                        result = Object.values(noteVotes)
                            .filter(v => v.count === numAlgos)
                            .map(v => ({
                                ...v.bestNote,
                                confidence: v.totalConfidence / numAlgos
                            }));
                        break;
                        
                    case 'voting':
                        // T√∂ne die von der Mehrheit erkannt wurden
                        const threshold = Math.ceil(numAlgos / 2);
                        result = Object.values(noteVotes)
                            .filter(v => v.count >= threshold)
                            .map(v => ({
                                ...v.bestNote,
                                confidence: v.count / numAlgos
                            }));
                        break;
                        
                    case 'strongest':
                        // Nur die T√∂ne mit h√∂chster durchschnittlicher Confidence
                        result = Object.values(noteVotes)
                            .map(v => ({
                                ...v.bestNote,
                                confidence: v.totalConfidence / v.count
                            }))
                            .sort((a, b) => b.confidence - a.confidence)
                            .slice(0, 4);
                        break;
                }
                
                // Sortiere nach Tonh√∂he
                result.sort((a, b) => a.midi - b.midi);
                
                return result.slice(0, 4);
            }
            
            // ========== HPS ==========
            detectHPS(useWhitening) {
                const minFreq = 80;
                const maxFreq = 2000;
                const minBin = Math.floor(this.freqToBin(minFreq));
                const maxBin = Math.ceil(this.freqToBin(maxFreq));
                
                // HPS
                const hps = this.computeHPS(this.frequencyData, minBin, maxBin);
                
                // Optional Whitening
                const processed = useWhitening ? this.applyWhitening(hps, 30) : hps;
                
                // Dynamischer Threshold
                let sum = 0, count = 0;
                for (let i = minBin; i < Math.min(processed.length, maxBin); i++) {
                    sum += processed[i];
                    count++;
                }
                const avgLevel = sum / count;
                const threshold = avgLevel + 5 + (1 - sensitivity) * 15;
                
                // Peak Detection
                const peaks = this.detectPeaksImproved(processed, minBin, Math.min(processed.length, maxBin), threshold);
                
                return this.extractFundamentals(peaks, 4);
            }
            
            // ========== Simple Peak Detection ==========
            detectSimplePeaks() {
                const minFreq = 80;
                const maxFreq = 2000;
                const minBin = Math.floor(this.freqToBin(minFreq));
                const maxBin = Math.ceil(this.freqToBin(maxFreq));
                
                const peaks = [];
                const threshold = -50 + (1 - sensitivity) * 30;
                
                for (let i = minBin + 1; i < maxBin - 1; i++) {
                    const prev = this.frequencyData[i - 1];
                    const curr = this.frequencyData[i];
                    const next = this.frequencyData[i + 1];
                    
                    if (curr > prev && curr > next && curr > threshold) {
                        const delta = 0.5 * (prev - next) / (prev - 2 * curr + next);
                        const freq = this.binToFreq(i + delta);
                        
                        peaks.push({
                            frequency: freq,
                            magnitude: curr,
                            confidence: 0.5
                        });
                    }
                }
                
                peaks.sort((a, b) => b.magnitude - a.magnitude);
                return this.extractFundamentals(peaks.slice(0, 10), 4);
            }
            
            // ========== Autocorrelation ==========
            detectAutocorrelation() {
                const buffer = this.timeData;
                const SIZE = buffer.length;
                
                // RMS Check
                let rms = 0;
                for (let i = 0; i < SIZE; i++) {
                    rms += buffer[i] * buffer[i];
                }
                rms = Math.sqrt(rms / SIZE);
                if (rms < 0.01) return [];
                
                // Autocorrelation
                const correlations = new Float32Array(SIZE);
                for (let lag = 0; lag < SIZE; lag++) {
                    let sum = 0;
                    for (let i = 0; i < SIZE - lag; i++) {
                        sum += buffer[i] * buffer[i + lag];
                    }
                    correlations[lag] = sum;
                }
                
                // Finde erstes Maximum nach erstem Minimum
                let d = 0;
                while (correlations[d] > correlations[d + 1] && d < SIZE / 2) d++;
                
                let maxVal = -1, maxPos = -1;
                for (let i = d; i < SIZE / 2; i++) {
                    if (correlations[i] > maxVal) {
                        maxVal = correlations[i];
                        maxPos = i;
                    }
                }
                
                if (maxPos === -1) return [];
                
                const freq = this.sampleRate / maxPos;
                if (freq < 80 || freq > 2000) return [];
                
                const midi = Math.round(this.freqToMidi(freq));
                return [{
                    ...this.midiToNote(midi),
                    frequency: freq,
                    magnitude: maxVal,
                    confidence: Math.min(1, maxVal / correlations[0])
                }];
            }
            
            // ========== Cepstrum ==========
            detectCepstrum() {
                const minFreq = 80;
                const maxFreq = 2000;
                
                // Log-Magnitude Spektrum
                const logMag = new Float32Array(this.frequencyData.length);
                for (let i = 0; i < this.frequencyData.length; i++) {
                    logMag[i] = Math.log(Math.max(0.0001, Math.pow(10, this.frequencyData[i] / 20)));
                }
                
                // "Cepstrum" via Peak im Quefrency-Bereich
                // Vereinfacht: Suche nach periodischen Mustern im Log-Spektrum
                const minQuefrency = Math.floor(this.sampleRate / maxFreq);
                const maxQuefrency = Math.floor(this.sampleRate / minFreq);
                
                // Differenz-basierte Peak-Suche
                let bestQuefrency = 0;
                let bestScore = 0;
                
                for (let q = minQuefrency; q < maxQuefrency; q++) {
                    let score = 0;
                    const freqStep = this.sampleRate / q;
                    
                    // Pr√ºfe ob Harmonische vorhanden
                    for (let h = 1; h <= 5; h++) {
                        const bin = Math.round(this.freqToBin(freqStep * h));
                        if (bin < this.frequencyData.length) {
                            score += Math.pow(10, this.frequencyData[bin] / 20);
                        }
                    }
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestQuefrency = q;
                    }
                }
                
                if (bestQuefrency === 0) return [];
                
                const freq = this.sampleRate / bestQuefrency;
                const midi = Math.round(this.freqToMidi(freq));
                
                return [{
                    ...this.midiToNote(midi),
                    frequency: freq,
                    magnitude: bestScore,
                    confidence: 0.7
                }];
            }
            
            // ========== YIN Algorithm ==========
            detectYIN() {
                const buffer = this.timeData;
                const SIZE = buffer.length;
                const threshold = 0.1;
                
                // RMS Check
                let rms = 0;
                for (let i = 0; i < SIZE; i++) {
                    rms += buffer[i] * buffer[i];
                }
                rms = Math.sqrt(rms / SIZE);
                if (rms < 0.01) return [];
                
                const yinBuffer = new Float32Array(SIZE / 2);
                
                // Step 1 & 2: Differenzfunktion
                for (let tau = 1; tau < SIZE / 2; tau++) {
                    let sum = 0;
                    for (let i = 0; i < SIZE / 2; i++) {
                        const delta = buffer[i] - buffer[i + tau];
                        sum += delta * delta;
                    }
                    yinBuffer[tau] = sum;
                }
                
                // Step 3: Kumulative Mean Normalized Differenz
                yinBuffer[0] = 1;
                let runningSum = 0;
                for (let tau = 1; tau < SIZE / 2; tau++) {
                    runningSum += yinBuffer[tau];
                    yinBuffer[tau] *= tau / runningSum;
                }
                
                // Step 4: Absolutes Threshold
                let tauEstimate = -1;
                for (let tau = 2; tau < SIZE / 2; tau++) {
                    if (yinBuffer[tau] < threshold) {
                        while (tau + 1 < SIZE / 2 && yinBuffer[tau + 1] < yinBuffer[tau]) {
                            tau++;
                        }
                        tauEstimate = tau;
                        break;
                    }
                }
                
                if (tauEstimate === -1) return [];
                
                // Step 5: Parabolic Interpolation
                let betterTau = tauEstimate;
                if (tauEstimate > 0 && tauEstimate < SIZE / 2 - 1) {
                    const s0 = yinBuffer[tauEstimate - 1];
                    const s1 = yinBuffer[tauEstimate];
                    const s2 = yinBuffer[tauEstimate + 1];
                    betterTau = tauEstimate + (s2 - s0) / (2 * (2 * s1 - s2 - s0));
                }
                
                const freq = this.sampleRate / betterTau;
                if (freq < 80 || freq > 2000) return [];
                
                const midi = Math.round(this.freqToMidi(freq));
                const confidence = 1 - yinBuffer[tauEstimate];
                
                return [{
                    ...this.midiToNote(midi),
                    frequency: freq,
                    magnitude: 0,
                    confidence: Math.max(0, Math.min(1, confidence))
                }];
            }
        }
        
        let pitchDetector = null;

        // ============================================
        // PERCUSSION DETECTOR
        // ============================================
        
        class PercussionDetector {
            constructor(audioContext, analyser) {
                this.audioContext = audioContext;
                this.analyser = analyser;
                this.sampleRate = audioContext.sampleRate;
                this.fftSize = analyser.fftSize;
                
                this.frequencyData = new Float32Array(analyser.frequencyBinCount);
                this.timeData = new Float32Array(analyser.fftSize);
                
                // Onset Detection
                this.prevEnergy = 0;
                this.energyHistory = [];
                this.historySize = 43; // ~1 Sekunde bei 43 fps
                this.onsetThreshold = 1.5;
                this.lastOnsetTime = 0;
                this.onsetCooldown = 50; // ms zwischen Onsets
                
                // Percussion States
                this.percussionStates = {
                    kick: { active: false, decay: 0 },
                    snare: { active: false, decay: 0 },
                    'hihat-closed': { active: false, decay: 0 },
                    'hihat-open': { active: false, decay: 0 },
                    tom: { active: false, decay: 0 },
                    crash: { active: false, decay: 0 }
                };
                
                this.decayRate = 0.85;
            }
            
            binToFreq(bin) {
                return bin * this.sampleRate / this.fftSize;
            }
            
            freqToBin(freq) {
                return Math.round(freq * this.fftSize / this.sampleRate);
            }
            
            getEnergyInRange(lowFreq, highFreq) {
                const lowBin = this.freqToBin(lowFreq);
                const highBin = this.freqToBin(highFreq);
                let energy = 0;
                for (let i = lowBin; i <= highBin && i < this.frequencyData.length; i++) {
                    const magnitude = Math.pow(10, this.frequencyData[i] / 20);
                    energy += magnitude * magnitude;
                }
                return energy;
            }
            
            detect() {
                this.analyser.getFloatFrequencyData(this.frequencyData);
                this.analyser.getFloatTimeDomainData(this.timeData);
                
                // Gesamt-Energie berechnen
                let totalEnergy = 0;
                for (let i = 0; i < this.timeData.length; i++) {
                    totalEnergy += this.timeData[i] * this.timeData[i];
                }
                totalEnergy = Math.sqrt(totalEnergy / this.timeData.length);
                
                // Energie-Historie updaten
                this.energyHistory.push(totalEnergy);
                if (this.energyHistory.length > this.historySize) {
                    this.energyHistory.shift();
                }
                
                // Durchschnitt berechnen
                const avgEnergy = this.energyHistory.reduce((a, b) => a + b, 0) / this.energyHistory.length;
                
                // Onset Detection
                const now = performance.now();
                const isOnset = totalEnergy > avgEnergy * this.onsetThreshold && 
                               totalEnergy > this.prevEnergy * 1.1 &&
                               (now - this.lastOnsetTime) > this.onsetCooldown;
                
                if (isOnset) {
                    this.lastOnsetTime = now;
                    this.classifyPercussion();
                    console.log('Percussion onset detected, energy:', totalEnergy.toFixed(4), 'avg:', avgEnergy.toFixed(4));
                }
                
                this.prevEnergy = totalEnergy;
                
                // Decay anwenden
                for (const key in this.percussionStates) {
                    const state = this.percussionStates[key];
                    if (state.decay > 0) {
                        state.decay *= this.decayRate;
                        if (state.decay < 0.1) {
                            state.decay = 0;
                            state.active = false;
                        }
                    }
                }
                
                return this.percussionStates;
            }
            
            classifyPercussion() {
                // Energie in verschiedenen Frequenzbereichen
                const subBass = this.getEnergyInRange(20, 80);      // Sub-Bass
                const bass = this.getEnergyInRange(80, 200);        // Bass/Kick
                const lowMid = this.getEnergyInRange(200, 500);     // Snare Body
                const mid = this.getEnergyInRange(500, 2000);       // Tom/Snare
                const highMid = this.getEnergyInRange(2000, 6000);  // Snare Wire/Hi-Hat
                const high = this.getEnergyInRange(6000, 16000);    // Hi-Hat/Crash
                
                const total = subBass + bass + lowMid + mid + highMid + high + 0.0001;
                
                // Relative Verteilung
                const lowRatio = (subBass + bass) / total;
                const midRatio = (lowMid + mid) / total;
                const highRatio = (highMid + high) / total;
                
                console.log('Percussion ratios - low:', lowRatio.toFixed(2), 'mid:', midRatio.toFixed(2), 'high:', highRatio.toFixed(2));
                
                let detected = [];
                
                // Kick: Hauptenergie im Bass-Bereich
                if (lowRatio > 0.4) {
                    this.percussionStates.kick.active = true;
                    this.percussionStates.kick.decay = 1;
                    detected.push('KICK');
                }
                
                // Snare: Breitbandig mit hohem Anteil
                if (midRatio > 0.2 && highRatio > 0.15) {
                    this.percussionStates.snare.active = true;
                    this.percussionStates.snare.decay = 1;
                    detected.push('SNARE');
                }
                
                // Hi-Hat Closed: Sehr hoch
                if (highRatio > 0.4) {
                    this.percussionStates['hihat-closed'].active = true;
                    this.percussionStates['hihat-closed'].decay = 1;
                    detected.push('HH-C');
                }
                
                // Hi-Hat Open: Hoch aber breiter
                if (highRatio > 0.25 && highRatio < 0.45 && midRatio > 0.2) {
                    this.percussionStates['hihat-open'].active = true;
                    this.percussionStates['hihat-open'].decay = 1;
                    detected.push('HH-O');
                }
                
                // Tom: Mittlere Frequenzen dominant
                if (midRatio > 0.35 && lowRatio > 0.15 && highRatio < 0.3) {
                    this.percussionStates.tom.active = true;
                    this.percussionStates.tom.decay = 1;
                    detected.push('TOM');
                }
                
                // Crash: Breitbandig
                if (highRatio > 0.3 && midRatio > 0.15) {
                    this.percussionStates.crash.active = true;
                    this.percussionStates.crash.decay = 1;
                    detected.push('CRASH');
                }
                
                if (detected.length > 0) {
                    console.log('Detected:', detected.join(', '));
                }
            }
        }
        
        let percussionDetector = null;
        let percussionEnabled = false;
        const percussionEnabledCheckbox = document.getElementById('percussionEnabled');
        const detectedPercussionEl = document.getElementById('detectedPercussion');
        
        // Percussion UI initialisieren
        function initPercussionUI() {
            detectedPercussionEl.innerHTML = `
                <span class="perc-badge kick">KICK</span>
                <span class="perc-badge snare">SNARE</span>
                <span class="perc-badge hihat-closed">HH-C</span>
                <span class="perc-badge hihat-open">HH-O</span>
                <span class="perc-badge tom">TOM</span>
                <span class="perc-badge crash">CRASH</span>
            `;
        }
        
        function updatePercussionUI(states) {
            if (!states) return;
            
            for (const [name, state] of Object.entries(states)) {
                const badge = detectedPercussionEl.querySelector(`.perc-badge.${name}`);
                if (badge) {
                    if (state.active || state.decay > 0.3) {
                        badge.classList.add('active');
                    } else {
                        badge.classList.remove('active');
                    }
                }
            }
        }
        
        percussionEnabledCheckbox.addEventListener('change', (e) => {
            percussionEnabled = e.target.checked;
            console.log('Percussion enabled:', percussionEnabled, 'analyser:', !!analyser, 'audioContext:', !!audioContext);
            if (percussionEnabled) {
                initPercussionUI();
                if (analyser && audioContext) {
                    percussionDetector = new PercussionDetector(audioContext, analyser);
                    console.log('PercussionDetector erstellt');
                } else {
                    // Hinweis anzeigen
                    detectedPercussionEl.innerHTML = '<span style="color:#f80; font-size:8px;">Zuerst Audio starten!</span>';
                    console.log('Warte auf Audio-Start f√ºr Percussion...');
                }
            } else {
                detectedPercussionEl.innerHTML = '<span style="color:#666">-</span>';
                percussionDetector = null;
            }
        });

        // ============================================
        // SPEECH RECOGNITION
        // ============================================
        
        let speechRecognition = null;
        let speechEnabled = false;
        let speechHistory = [];
        const maxSpeechHistory = 5;
        
        // Textfilter-Einstellungen
        let aiFilterNouns = true;
        let aiFilterVerbs = false;
        let aiFilterAdj = false;
        
        const speechEnabledCheckbox = document.getElementById('speechEnabled');
        const speechLangSelect = document.getElementById('speechLang');
        const speechTextEl = document.getElementById('speechText');
        const speechStatus = document.getElementById('speechStatus');
        
        // ============================================
        // TEXTFILTER F√úR WORTARTEN (Deutsch/Englisch)
        // ============================================
        
        // Einfache Wortlisten f√ºr Filterung (kann erweitert werden)
        const GERMAN_STOPWORDS = new Set(['der', 'die', 'das', 'ein', 'eine', 'und', 'oder', 'aber', 'ist', 'sind', 'war', 'waren', 'wird', 'werden', 'hat', 'haben', 'ich', 'du', 'er', 'sie', 'es', 'wir', 'ihr', 'Sie', 'mein', 'dein', 'sein', 'ihr', 'unser', 'euer', 'in', 'an', 'auf', 'aus', 'bei', 'mit', 'nach', 'von', 'zu', 'f√ºr', '√ºber', 'unter', 'vor', 'hinter', 'neben', 'zwischen', 'durch', 'gegen', 'ohne', 'um', 'als', 'wenn', 'weil', 'dass', 'ob', 'nicht', 'auch', 'nur', 'noch', 'schon', 'sehr', 'so', 'wie', 'was', 'wer', 'wo', 'wann', 'warum', 'welche', 'welcher', 'welches', 'diesem', 'dieser', 'dieses', 'jeder', 'jede', 'jedes', 'alle', 'alles', 'mehr', 'viel', 'wenig', 'ganz', 'kann', 'k√∂nnte', 'm√∂chte', 'muss', 'soll', 'darf', 'will', 'w√ºrde']);
        
        const ENGLISH_STOPWORDS = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'is', 'are', 'was', 'were', 'will', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did', 'i', 'you', 'he', 'she', 'it', 'we', 'they', 'my', 'your', 'his', 'her', 'its', 'our', 'their', 'in', 'on', 'at', 'from', 'to', 'for', 'with', 'by', 'about', 'into', 'through', 'during', 'before', 'after', 'above', 'below', 'between', 'under', 'again', 'further', 'then', 'once', 'here', 'there', 'when', 'where', 'why', 'how', 'all', 'each', 'few', 'more', 'most', 'other', 'some', 'such', 'no', 'nor', 'not', 'only', 'own', 'same', 'so', 'than', 'too', 'very', 'can', 'just', 'should', 'now', 'would', 'could', 'of', 'if', 'as', 'this', 'that', 'these', 'those', 'what', 'which', 'who', 'whom']);
        
        // Deutsche Verb-Endungen
        const GERMAN_VERB_ENDINGS = ['en', 'st', 't', 'e', 'te', 'tet', 'ten', 'est', 'et'];
        // Deutsche Adjektiv-Endungen
        const GERMAN_ADJ_ENDINGS = ['ig', 'lich', 'isch', 'bar', 'sam', 'haft', 'los', 'voll', 'reich', 'arm', 'er', 'ere', 'erer', 'ste', 'sten'];
        
        // Englische Verb-Endungen
        const ENGLISH_VERB_ENDINGS = ['ing', 'ed', 's', 'es'];
        // Englische Adjektiv-Endungen  
        const ENGLISH_ADJ_ENDINGS = ['ful', 'less', 'ous', 'ive', 'able', 'ible', 'al', 'ial', 'ic', 'ly', 'y', 'ish', 'ent', 'ant'];
        
        function filterTextByWordType(text, filterNouns, filterVerbs, filterAdj) {
            if (!text) return '';
            
            // Wenn alle Filter aus sind, gib den ganzen Text zur√ºck
            if (!filterNouns && !filterVerbs && !filterAdj) {
                return text;
            }
            
            const lang = speechLangSelect.value.startsWith('de') ? 'de' : 'en';
            const stopwords = lang === 'de' ? GERMAN_STOPWORDS : ENGLISH_STOPWORDS;
            const verbEndings = lang === 'de' ? GERMAN_VERB_ENDINGS : ENGLISH_VERB_ENDINGS;
            const adjEndings = lang === 'de' ? GERMAN_ADJ_ENDINGS : ENGLISH_ADJ_ENDINGS;
            
            const words = text.split(/\s+/).filter(w => w.length > 0);
            const filteredWords = [];
            
            for (const word of words) {
                const cleanWord = word.toLowerCase().replace(/[.,!?;:'"()]/g, '');
                
                // Stopwords √ºberspringen
                if (stopwords.has(cleanWord)) continue;
                if (cleanWord.length < 2) continue;
                
                // Wortart erkennen (heuristische Methode)
                let isVerb = false;
                let isAdj = false;
                let isNoun = false;
                
                // Verb-Check
                for (const ending of verbEndings) {
                    if (cleanWord.endsWith(ending) && cleanWord.length > ending.length + 2) {
                        isVerb = true;
                        break;
                    }
                }
                
                // Adjektiv-Check
                for (const ending of adjEndings) {
                    if (cleanWord.endsWith(ending) && cleanWord.length > ending.length + 2) {
                        isAdj = true;
                        break;
                    }
                }
                
                // Substantiv: Gro√ügeschrieben (Deutsch) oder nicht Verb/Adj
                if (lang === 'de' && word[0] === word[0].toUpperCase() && word[0] !== word[0].toLowerCase()) {
                    isNoun = true;
                } else if (!isVerb && !isAdj) {
                    // Im Englischen: Wenn nicht als Verb/Adj erkannt, k√∂nnte es ein Nomen sein
                    isNoun = true;
                }
                
                // Filtern basierend auf Einstellungen
                let include = false;
                if (filterNouns && isNoun) include = true;
                if (filterVerbs && isVerb) include = true;
                if (filterAdj && isAdj) include = true;
                
                if (include) {
                    filteredWords.push(word);
                }
            }
            
            return filteredWords.join(' ');
        }
        
        // Funktion um Text ins Prompt-Feld zu √ºbertragen (mit Filter)
        function updatePromptFromSpeech(rawText) {
            const filteredText = filterTextByWordType(rawText, aiFilterNouns, aiFilterVerbs, aiFilterAdj);
            
            // Ins Prompt-Eingabefeld schreiben
            if (aiPromptInput) {
                // Bestehenden Text erweitern oder ersetzen
                const currentPrompt = aiPromptInput.value.trim();
                if (currentPrompt && !currentPrompt.endsWith(filteredText)) {
                    // Neuen Text anh√§ngen
                    aiPromptInput.value = currentPrompt + ' ' + filteredText;
                } else {
                    aiPromptInput.value = filteredText;
                }
            }
            
            // Status-Anzeige aktualisieren
            const aiCurrentInput = document.getElementById('aiCurrentInput');
            if (aiCurrentInput) {
                const filterInfo = [];
                if (aiFilterNouns) filterInfo.push('N');
                if (aiFilterVerbs) filterInfo.push('V');
                if (aiFilterAdj) filterInfo.push('A');
                const filterStr = filterInfo.length > 0 ? ` [${filterInfo.join('+')}]` : '';
                aiCurrentInput.textContent = `üé§ ${rawText}${filterStr}`;
            }
            
            return filteredText;
        }
        
        // Speech Recognition initialisieren
        function initSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            
            console.log('SpeechRecognition API verf√ºgbar:', !!SpeechRecognition);
            
            if (!SpeechRecognition) {
                speechStatus.innerHTML = '‚ùå Nicht verf√ºgbar (nur Chrome)';
                speechStatus.style.color = '#f66';
                speechEnabledCheckbox.disabled = true;
                return null;
            }
            
            const recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = speechLangSelect.value;
            recognition.maxAlternatives = 1;
            
            recognition.onstart = () => {
                console.log('Speech Recognition gestartet');
                speechStatus.innerHTML = 'üî¥ H√∂rt zu...';
                speechStatus.style.color = '#4f4';
            };
            
            recognition.onend = () => {
                console.log('Speech Recognition beendet');
                if (speechEnabled) {
                    speechStatus.innerHTML = 'üü° Neustart...';
                    speechStatus.style.color = '#ff0';
                    setTimeout(() => {
                        if (speechEnabled && speechRecognition) {
                            try {
                                speechRecognition.start();
                            } catch (e) {
                                console.log('Restart error:', e);
                            }
                        }
                    }, 300);
                } else {
                    speechStatus.innerHTML = '‚è∏ Aus';
                    speechStatus.style.color = '#888';
                }
            };
            
            recognition.onerror = (event) => {
                console.log('Speech error:', event.error);
                if (event.error === 'no-speech') {
                    speechStatus.innerHTML = 'üî¥ ...';
                } else if (event.error === 'audio-capture') {
                    speechStatus.innerHTML = '‚ùå Kein Mikrofon!';
                    speechStatus.style.color = '#f66';
                } else if (event.error === 'not-allowed') {
                    speechStatus.innerHTML = '‚ùå Nicht erlaubt!';
                    speechStatus.style.color = '#f66';
                    speechEnabledCheckbox.checked = false;
                    speechEnabled = false;
                } else if (event.error === 'network') {
                    speechStatus.innerHTML = '‚ùå Netzwerk!';
                    speechStatus.style.color = '#f66';
                } else if (event.error === 'aborted') {
                    // Ignorieren
                } else {
                    speechStatus.innerHTML = '‚ö† ' + event.error;
                    speechStatus.style.color = '#f80';
                }
            };
            
            recognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }
                
                console.log('Speech result - interim:', interimTranscript, 'final:', finalTranscript);
                
                if (finalTranscript) {
                    speechHistory.push(finalTranscript.trim());
                    if (speechHistory.length > maxSpeechHistory) {
                        speechHistory.shift();
                    }
                    // Letzte Eingabe f√ºr AI speichern
                    window.aiLastSpeechInput = finalTranscript.trim();
                    // Text filtern und ins Prompt-Feld √ºbertragen
                    updatePromptFromSpeech(finalTranscript.trim());
                    updateSpeechUI('');
                } else {
                    updateSpeechUI(interimTranscript);
                }
            };
            
            recognition.onsoundstart = () => {
                console.log('Speech: Sound erkannt');
                speechStatus.innerHTML = 'üü¢ Sound...';
                speechStatus.style.color = '#4f4';
            };
            
            recognition.onspeechstart = () => {
                console.log('Speech: Sprache erkannt!');
                speechStatus.innerHTML = 'üü¢ Sprache!';
                speechStatus.style.color = '#4f4';
            };
            
            return recognition;
        }
        
        function updateSpeechUI(interim = '') {
            let html = '';
            
            speechHistory.forEach(text => {
                html += `<div class="final">${text}</div>`;
            });
            
            if (interim) {
                html += `<div class="interim">${interim}</div>`;
            }
            
            speechTextEl.innerHTML = html;
            speechTextEl.scrollTop = speechTextEl.scrollHeight;
        }
        
        // Event Handler
        speechEnabledCheckbox.addEventListener('change', (e) => {
            speechEnabled = e.target.checked;
            console.log('Speech enabled:', speechEnabled);
            
            if (speechEnabled) {
                speechStatus.innerHTML = 'üü° Starte...';
                speechStatus.style.color = '#ff0';
                
                if (!speechRecognition) {
                    speechRecognition = initSpeechRecognition();
                    console.log('Speech Recognition erstellt:', !!speechRecognition);
                }
                if (speechRecognition) {
                    speechRecognition.lang = speechLangSelect.value;
                    try {
                        speechRecognition.start();
                        console.log('Speech Recognition gestartet');
                    } catch (e) {
                        console.log('Speech start error:', e);
                        speechStatus.innerHTML = '‚ö† Fehler';
                        speechStatus.style.color = '#f80';
                    }
                }
            } else {
                if (speechRecognition) {
                    speechRecognition.stop();
                }
                speechHistory = [];
                speechTextEl.innerHTML = '';
                speechStatus.innerHTML = '‚è∏ Aus';
                speechStatus.style.color = '#888';
            }
        });
        
        speechLangSelect.addEventListener('change', (e) => {
            if (speechRecognition) {
                const wasEnabled = speechEnabled;
                if (wasEnabled) {
                    speechRecognition.stop();
                }
                speechRecognition.lang = e.target.value;
                if (wasEnabled) {
                    setTimeout(() => {
                        try {
                            speechRecognition.start();
                        } catch (e) {}
                    }, 100);
                }
            }
        });

        // ============================================
        // INTERVALL-ANALYSE
        // ============================================
        
        function analyzeIntervals(notes) {
            if (notes.length === 0) return null;
            
            // Bei nur einem Ton: trotzdem Analyse zur√ºckgeben f√ºr Farbdarstellung
            if (notes.length === 1) {
                return {
                    intervals: [],
                    chord: null,
                    bass: notes[0],
                    notes: notes
                };
            }
            
            const intervals = [];
            
            for (let i = 0; i < notes.length - 1; i++) {
                for (let j = i + 1; j < notes.length; j++) {
                    const semitones = notes[j].midi - notes[i].midi;
                    
                    // Verwende das echte Intervall f√ºr Namen (None, Dezime, etc.)
                    // Nur f√ºr sehr gro√üe Intervalle auf Oktav-√Ñquivalent zur√ºckfallen
                    const displayInterval = semitones <= 24 ? semitones : (semitones % 12) || 12;
                    
                    intervals.push({
                        semitones: semitones,
                        lower: notes[i],
                        upper: notes[j],
                        name: IntervalNames[displayInterval]?.name || `${semitones} Halbt√∂ne`,
                        short: IntervalNames[displayInterval]?.short || `${semitones}ht`
                    });
                }
            }
            
            const chord = detectChord(notes);
            
            return {
                intervals,
                chord,
                bass: notes[0],
                notes: notes
            };
        }
        
        function detectChord(notes) {
            if (notes.length < 2) return null;
            
            const intervals = notes.slice(1).map(n => (n.midi - notes[0].midi) % 12);
            intervals.sort((a, b) => a - b);
            const pattern = intervals.join(',');
            
            const chordPatterns = {
                '4,7': { type: 'major', name: 'Dur' },
                '3,7': { type: 'minor', name: 'Moll' },
                '3,6': { type: 'diminished', name: 'Vermindert' },
                '4,8': { type: 'augmented', name: '√úberm√§√üig' },
                '4,7,10': { type: 'dominant7', name: 'Dominant 7' },
                '4,7,11': { type: 'major7', name: 'Major 7' },
                '3,7,10': { type: 'minor7', name: 'Moll 7' },
                '7': { type: 'power', name: 'Powerchord' },
                '5': { type: 'sus4', name: 'Sus4' },
                '2,7': { type: 'sus2', name: 'Sus2' },
            };
            
            const match = chordPatterns[pattern];
            if (match) {
                return {
                    root: notes[0].name,
                    ...match,
                    full: notes[0].name + (match.type === 'minor' ? 'm' : match.type === 'major' ? '' : match.name)
                };
            }
            
            return null;
        }

        // ============================================
        // FARBBERECHNUNG
        // ============================================
        
        let activeSchema = 'clara';
        let lastAnalysis = null; // Cache f√ºr schnelle Updates
        let blendEnabled = false;
        let blendAmount = 0.5;
        let alexDegreeColorsEnabled = false;
        
        // Default-Analyse f√ºr sofortige Darstellung (C-Dur Akkord)
        const defaultAnalysis = {
            notes: [
                { name: 'C', midi: 60, octave: 4, isSharp: false, confidence: 1, frequency: 261.63 },
                { name: 'E', midi: 64, octave: 4, isSharp: false, confidence: 1, frequency: 329.63 },
                { name: 'G', midi: 67, octave: 4, isSharp: false, confidence: 1, frequency: 392.00 }
            ],
            bass: { name: 'C', midi: 60, octave: 4, isSharp: false, confidence: 1, frequency: 261.63 },
            intervals: [
                { semitones: 4, name: 'Gro√üe Terz' },
                { semitones: 7, name: 'Quinte' }
            ],
            chordType: 'major'
        };
        
        // Schnelle Aktualisierung - wird sp√§ter √ºberschrieben wenn applyColors verf√ºgbar
        let refreshVisuals = function() {
            // Placeholder bis applyColors definiert ist
        };
        
        function getColorForNote(note, schema = activeSchema) {
            if (schema === 'clara') {
                const colorSet = ClaraColors.notes[note.name.replace('#', '').replace('b', '')];
                if (!colorSet) return 0xffffff;
                
                if (note.isSharp && colorSet.sharp) return colorSet.sharp;
                if (note.name.includes('b') && colorSet.flat) return colorSet.flat;
                return colorSet.base;
            }
            
            return 0xffffff;
        }
        
        function getColorForChord(analysis, schema = activeSchema) {
            if (!analysis) return 0x333333;
            
            if (schema === 'clara') {
                return getColorForNote(analysis.bass, 'clara');
            }
            
            if (schema === 'alex') {
                if (analysis.chord) {
                    if (analysis.chord.type === 'minor' || analysis.chord.type === 'minor7') {
                        return AlexColors.modes.minor;
                    }
                    return AlexColors.modes.major;
                }
                if (analysis.intervals.length > 0) {
                    const mainInterval = analysis.intervals[0].normalized;
                    if (mainInterval === 3 || mainInterval === 8) {
                        return AlexColors.modes.minor;
                    }
                    return AlexColors.modes.major;
                }
            }
            
            if (schema === 'both') {
                const claraColor = new THREE.Color(getColorForChord(analysis, 'clara'));
                const alexColor = new THREE.Color(getColorForChord(analysis, 'alex'));
                
                if (blendEnabled) {
                    claraColor.lerp(alexColor, blendAmount);
                    return claraColor.getHex();
                }
                
                return claraColor.getHex();
            }
            
            return 0x666666;
        }
        
        function applyColors(analysis) {
            if (!analysis) return;
            
            // Cache die Analyse f√ºr schnelle Updates
            lastAnalysis = analysis;
            
            // Gain-Multiplikator f√ºr Helligkeit (0-1)
            const gainMult = gainLinked ? currentGainLevel : 1;
            
            // === MODELL-SICHTBARKEIT ===
            // Alex: Kein Modell, nur Hintergrund
            // Clara/Beide: Modell sichtbar
            if (currentModel) {
                currentModel.visible = (activeSchema !== 'alex');
            }
            
            // === MODELL-FARBEN (IMMER NUR CLARA - unabh√§ngig vom Schema) ===
            if (activeSchema !== 'alex' && analysis.bass) {
                // Direkt Clara-Farbe vom Bass-Ton holen
                const bassNote = analysis.bass;
                const noteName = bassNote.name.replace('#', '').replace('b', '');
                const colorSet = ClaraColors.notes[noteName];
                let claraHex = 0xff3333; // Fallback Rot
                
                if (colorSet) {
                    if (bassNote.isSharp && colorSet.sharp) {
                        claraHex = colorSet.sharp;
                    } else if (bassNote.name.includes('b') && colorSet.flat) {
                        claraHex = colorSet.flat;
                    } else {
                        claraHex = colorSet.base;
                    }
                }
                
                const mainColor = new THREE.Color(claraHex);
                
                // Partikelfarbe aktualisieren
                if (particlesEnabled) {
                    setParticleColor(claraHex);
                }
                
                // Farbe auf alle Materialien anwenden (auch wenn modelMaterials leer, direkt auf Modell)
                if (modelMaterials.length > 0) {
                    modelMaterials.forEach((mat, index) => {
                        const variation = mainColor.clone();
                        variation.offsetHSL(0, 0, (index * 0.015) - 0.02);
                        variation.multiplyScalar(gainMult);
                        
                        mat.color.copy(variation);
                        mat.emissive = variation.clone().multiplyScalar(0.5);
                    });
                } else if (currentModel) {
                    // Fallback: Direkt auf Modell-Meshes anwenden
                    currentModel.traverse((child) => {
                        if (child.isMesh && child.material) {
                            const variation = mainColor.clone();
                            variation.multiplyScalar(gainMult);
                            child.material.color.copy(variation);
                            child.material.emissive = variation.clone().multiplyScalar(0.5);
                        }
                    });
                }
            }
            
            // === HINTERGRUND-FARBEN ===
            if (activeSchema === 'clara') {
                // Clara: Schwarzer Hintergrund
                renderer.setClearColor(0x111111);
                vignetteOverlay.classList.remove('active');
                currentVignetteColor = null;
            } else {
                // Alex oder Beide: Modus-Farbe oder Stufen-Farben
                let bgColor;
                
                if (alexDegreeColorsEnabled && analysis.notes.length >= 2) {
                    // Stufen-Farben als Hintergrund-Gradient
                    const bassNote = analysis.bass.midi;
                    const degreeColors = analysis.notes.map(note => {
                        const interval = (note.midi - bassNote) % 12;
                        return new THREE.Color(AlexColors.degrees[interval] || 0xffffff);
                    });
                    
                    // Mische alle Stufen-Farben f√ºr den Hintergrund
                    bgColor = degreeColors[0].clone();
                    for (let i = 1; i < degreeColors.length; i++) {
                        bgColor.lerp(degreeColors[i], 1 / (i + 1));
                    }
                    bgColor.multiplyScalar(gainMult);
                    
                    if (alexVignetteEnabled) {
                        // Multi-Color Vignette mit Stufen-Farben
                        renderer.setClearColor(0x000000);
                        
                        if (alexGradientEnabled && degreeColors.length >= 2) {
                            // Gradient-Vignette mit mehreren Farben
                            const colors = degreeColors.map(c => {
                                c.multiplyScalar(gainMult);
                                return `rgba(${Math.round(c.r*255)}, ${Math.round(c.g*255)}, ${Math.round(c.b*255)}, ${0.6 * gainMult})`;
                            });
                            
                            // Radialer Gradient mit allen Stufen-Farben
                            const stops = colors.map((c, i) => {
                                const pos = (i / (colors.length - 1)) * 60;
                                return `${c} ${pos}%`;
                            }).join(', ');
                            
                            vignetteOverlay.style.background = `
                                radial-gradient(
                                    ellipse at center,
                                    ${stops},
                                    rgba(0, 0, 0, 0) 85%
                                )
                            `;
                            
                            // Speichere f√ºr Stream (erste Farbe)
                            const firstColor = degreeColors[0];
                            currentVignetteColor = { r: firstColor.r, g: firstColor.g, b: firstColor.b, a: 0.6 * gainMult };
                        } else {
                            // Einfache Vignette mit gemischter Farbe
                            const r = Math.round(bgColor.r * 255);
                            const g = Math.round(bgColor.g * 255);
                            const b = Math.round(bgColor.b * 255);
                            vignetteOverlay.style.background = `
                                radial-gradient(
                                    ellipse at center,
                                    rgba(${r}, ${g}, ${b}, ${0.5 * gainMult}) 0%,
                                    rgba(${r}, ${g}, ${b}, ${0.45 * gainMult}) 8%,
                                    rgba(${r}, ${g}, ${b}, ${0.38 * gainMult}) 16%,
                                    rgba(${r}, ${g}, ${b}, ${0.30 * gainMult}) 24%,
                                    rgba(${r}, ${g}, ${b}, ${0.22 * gainMult}) 32%,
                                    rgba(${r}, ${g}, ${b}, ${0.16 * gainMult}) 40%,
                                    rgba(${r}, ${g}, ${b}, ${0.11 * gainMult}) 48%,
                                    rgba(${r}, ${g}, ${b}, ${0.07 * gainMult}) 56%,
                                    rgba(${r}, ${g}, ${b}, ${0.04 * gainMult}) 64%,
                                    rgba(${r}, ${g}, ${b}, ${0.02 * gainMult}) 72%,
                                    rgba(${r}, ${g}, ${b}, ${0.008 * gainMult}) 80%,
                                    rgba(0, 0, 0, 0) 90%
                                )
                            `;
                            
                            // Speichere f√ºr Stream
                            currentVignetteColor = { r: bgColor.r, g: bgColor.g, b: bgColor.b, a: 0.5 * gainMult };
                        }
                        vignetteOverlay.classList.add('active');
                    } else {
                        // Vollfl√§chige gemischte Stufen-Farbe
                        bgColor.multiplyScalar(0.25);
                        renderer.setClearColor(bgColor);
                        vignetteOverlay.classList.remove('active');
                        currentVignetteColor = null;
                    }
                } else {
                    // Standard Modus-Farbe (Moll = Blau, Dur = Rot/Orange)
                    bgColor = new THREE.Color(getColorForChord(analysis, 'alex'));
                    bgColor.multiplyScalar(gainMult);
                    
                    if (alexVignetteEnabled) {
                        renderer.setClearColor(0x000000);
                        const r = Math.round(bgColor.r * 255);
                        const g = Math.round(bgColor.g * 255);
                        const b = Math.round(bgColor.b * 255);
                        vignetteOverlay.style.background = `
                            radial-gradient(
                                ellipse at center,
                                rgba(${r}, ${g}, ${b}, ${0.5 * gainMult}) 0%,
                                rgba(${r}, ${g}, ${b}, ${0.45 * gainMult}) 8%,
                                rgba(${r}, ${g}, ${b}, ${0.38 * gainMult}) 16%,
                                rgba(${r}, ${g}, ${b}, ${0.30 * gainMult}) 24%,
                                rgba(${r}, ${g}, ${b}, ${0.22 * gainMult}) 32%,
                                rgba(${r}, ${g}, ${b}, ${0.16 * gainMult}) 40%,
                                rgba(${r}, ${g}, ${b}, ${0.11 * gainMult}) 48%,
                                rgba(${r}, ${g}, ${b}, ${0.07 * gainMult}) 56%,
                                rgba(${r}, ${g}, ${b}, ${0.04 * gainMult}) 64%,
                                rgba(${r}, ${g}, ${b}, ${0.02 * gainMult}) 72%,
                                rgba(${r}, ${g}, ${b}, ${0.008 * gainMult}) 80%,
                                rgba(0, 0, 0, 0) 90%
                            )
                        `;
                        vignetteOverlay.classList.add('active');
                        
                        // Speichere f√ºr Stream
                        currentVignetteColor = { r: bgColor.r, g: bgColor.g, b: bgColor.b, a: 0.5 * gainMult };
                    } else {
                        bgColor.multiplyScalar(0.25);
                        renderer.setClearColor(bgColor);
                        vignetteOverlay.classList.remove('active');
                        currentVignetteColor = null;
                    }
                }
            }
        }
        
        // Schnelle Aktualisierung mit gecachter Analyse - √ºberschreibt Placeholder
        refreshVisuals = function() {
            // Verwende gecachte Analyse oder Default
            const analysis = lastAnalysis || defaultAnalysis;
            applyColors(analysis);
        };

        // ============================================
        // UI UPDATES
        // ============================================
        
        const detectedNotesEl = document.getElementById('detectedNotes');
        const intervalDisplayEl = document.getElementById('intervalDisplay');
        const debugInfoEl = document.getElementById('debugInfo');
        const levelMeter = document.getElementById('levelMeter');
        
        function updateUI(notes, analysis) {
            if (notes.length === 0) {
                detectedNotesEl.innerHTML = '<span style="color:#666">Keine T√∂ne erkannt</span>';
            } else {
                detectedNotesEl.innerHTML = notes.map(note => {
                    const color = '#' + getColorForNote(note).toString(16).padStart(6, '0');
                    const conf = Math.round((note.confidence || 0.5) * 100);
                    return `<span class="note-badge" style="background:${color}">
                        ${note.full}
                        <span class="confidence"><span class="confidence-fill" style="width:${conf}%"></span></span>
                    </span>`;
                }).join('');
            }
            
            if (analysis && analysis.intervals.length > 0) {
                const mainInterval = analysis.intervals[0];
                let display = mainInterval.name;
                
                if (analysis.chord) {
                    display = `${analysis.chord.root} ${analysis.chord.name}`;
                }
                
                intervalDisplayEl.textContent = display;
                
                // Modell wechseln basierend auf Intervall (Halbt√∂ne)
                const semitones = mainInterval.semitones;
                if (semitones !== currentModelSemitones) {
                    currentModelSemitones = semitones;
                    loadModel(semitones).catch(() => {});
                }
            } else if (notes.length === 1) {
                intervalDisplayEl.textContent = notes[0].full;
            } else {
                intervalDisplayEl.textContent = '-';
            }
            
            let degreeInfo = '';
            if (alexDegreeColorsEnabled && analysis && analysis.notes.length >= 2) {
                const bassNote = analysis.bass.midi;
                degreeInfo = analysis.notes.map(n => {
                    const interval = (n.midi - bassNote) % 12;
                    return `${n.name}=${AlexColors.degreeNames[interval]}`;
                }).join(', ');
            }
            
            debugInfoEl.innerHTML = `
                T√∂ne: ${notes.length}<br>
                Schema: ${activeSchema}<br>
                Blend: ${blendEnabled ? blendAmount.toFixed(2) : 'aus'}<br>
                Stufen: ${alexDegreeColorsEnabled ? (degreeInfo || '-') : 'aus'}
            `;
        }
        
        let currentModelFile = 'prime.glb';
        let currentModelSemitones = 0; // Aktuell geladenes Intervall in Halbt√∂nen
        
        // Algorithm Grid aufbauen
        const algoGrid = document.getElementById('algoGrid');
        const algoDescription = document.getElementById('algoDescription');
        const algoCombineMode = document.getElementById('algoCombineMode');
        
        function updateAlgoDescription() {
            const active = Array.from(activeAlgorithms);
            if (active.length === 0) {
                algoDescription.textContent = 'Mindestens einen Algorithmus w√§hlen!';
            } else if (active.length === 1) {
                algoDescription.textContent = PitchAlgorithms[active[0]].description;
            } else {
                const types = active.map(a => PitchAlgorithms[a].type);
                const polyCount = types.filter(t => t === 'poly').length;
                const monoCount = types.filter(t => t === 'mono').length;
                algoDescription.textContent = `Ensemble: ${active.length} Algos (${polyCount} poly, ${monoCount} mono) - ${combineMode}`;
            }
        }
        
        Object.entries(PitchAlgorithms).forEach(([key, algo]) => {
            const btn = document.createElement('button');
            btn.className = 'algo-btn' + (activeAlgorithms.has(key) ? ' active' : '');
            btn.textContent = algo.name;
            btn.dataset.algo = key;
            btn.addEventListener('click', () => {
                if (activeAlgorithms.has(key)) {
                    // Mindestens einer muss aktiv bleiben
                    if (activeAlgorithms.size > 1) {
                        activeAlgorithms.delete(key);
                        btn.classList.remove('active');
                    }
                } else {
                    activeAlgorithms.add(key);
                    btn.classList.add('active');
                }
                updateAlgoDescription();
            });
            algoGrid.appendChild(btn);
        });
        
        // Combine Mode
        algoCombineMode.addEventListener('change', (e) => {
            combineMode = e.target.value;
            updateAlgoDescription();
        });
        
        updateAlgoDescription();
        
        // Morphing Controls
        const morphingCheckbox = document.getElementById('morphingEnabled');
        const morphDurationSlider = document.getElementById('morphDuration');
        const morphDurationValue = document.getElementById('morphDurationValue');
        const morphDurationControl = document.getElementById('morphDurationControl');
        
        morphingCheckbox.addEventListener('change', (e) => {
            morphingEnabled = e.target.checked;
            morphDurationControl.style.opacity = morphingEnabled ? '1' : '0.5';
        });
        
        morphDurationSlider.addEventListener('input', (e) => {
            morphDuration = parseInt(e.target.value);
            morphDurationValue.textContent = `${morphDuration}ms`;
        });
        
        // Model Visibility Toggle
        const modelVisibleCheckbox = document.getElementById('modelVisible');
        let modelVisible = true;
        
        modelVisibleCheckbox.addEventListener('change', (e) => {
            modelVisible = e.target.checked;
            if (currentModel) {
                currentModel.visible = modelVisible;
            }
        });

        // ============================================
        // EVENT HANDLERS
        // ============================================
        
        const audioSourceSelect = document.getElementById('audioSourceSelect');
        const startBtn = document.getElementById('startBtn');
        let currentStream = null;
        
        async function loadAudioDevices() {
            try {
                await navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => stream.getTracks().forEach(t => t.stop()));
                
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(d => d.kind === 'audioinput');
                
                audioSourceSelect.innerHTML = '<option value="">-- Ger√§t w√§hlen --</option>';
                
                audioInputs.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Mikrofon ${index + 1}`;
                    audioSourceSelect.appendChild(option);
                });
                
                if (audioInputs.length > 0) {
                    audioSourceSelect.value = audioInputs[0].deviceId;
                    startBtn.disabled = false;
                }
                
            } catch (err) {
                console.error('Ger√§te-Fehler:', err);
                audioSourceSelect.innerHTML = '<option value="">Kein Zugriff</option>';
            }
        }
        
        navigator.mediaDevices.addEventListener('devicechange', () => {
            loadAudioDevices();
            loadAudioOutputDevices();
        });
        loadAudioDevices();
        
        // ============================================
        // AUDIO OUTPUT DEVICES
        // ============================================
        
        const audioOutputSelect = document.getElementById('audioOutputSelect');
        const audioPassthroughEnabled = document.getElementById('audioPassthroughEnabled');
        const passthroughVolume = document.getElementById('passthroughVolume');
        const passthroughVolumeValue = document.getElementById('passthroughVolumeValue');
        const passthroughVolumeControl = document.getElementById('passthroughVolumeControl');
        
        async function loadAudioOutputDevices() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioOutputs = devices.filter(d => d.kind === 'audiooutput');
                
                audioOutputSelect.innerHTML = '<option value="">-- Ausgabe w√§hlen --</option>';
                
                audioOutputs.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Lautsprecher ${index + 1}`;
                    audioOutputSelect.appendChild(option);
                });
                
                // Default-Ausgabe vorausw√§hlen wenn vorhanden
                if (audioOutputs.length > 0 && !currentOutputDeviceId) {
                    const defaultOutput = audioOutputs.find(d => d.deviceId === 'default') || audioOutputs[0];
                    audioOutputSelect.value = defaultOutput.deviceId;
                    currentOutputDeviceId = defaultOutput.deviceId;
                }
                
            } catch (err) {
                console.error('Audio-Ausgabe-Fehler:', err);
                audioOutputSelect.innerHTML = '<option value="">Nicht verf√ºgbar</option>';
            }
        }
        
        audioOutputSelect.addEventListener('change', async (e) => {
            currentOutputDeviceId = e.target.value;
            
            if (passthroughAudioElement && passthroughAudioElement.setSinkId && currentOutputDeviceId) {
                try {
                    await passthroughAudioElement.setSinkId(currentOutputDeviceId);
                    console.log('Audio-Ausgabe gewechselt zu:', currentOutputDeviceId);
                } catch (err) {
                    console.error('Fehler beim Wechseln der Audio-Ausgabe:', err);
                    alert('Konnte Ausgabeger√§t nicht wechseln: ' + err.message);
                }
            }
        });
        
        audioPassthroughEnabled.addEventListener('change', (e) => {
            passthroughEnabled = e.target.checked;
            
            if (passthroughGainNode) {
                const volume = parseInt(passthroughVolume.value) / 100;
                passthroughGainNode.gain.setValueAtTime(
                    passthroughEnabled ? volume : 0,
                    audioContext ? audioContext.currentTime : 0
                );
            }
            
            // UI Update
            passthroughVolume.disabled = !passthroughEnabled;
            passthroughVolumeControl.style.opacity = passthroughEnabled ? '1' : '0.5';
        });
        
        passthroughVolume.addEventListener('input', (e) => {
            const volume = parseInt(e.target.value) / 100;
            passthroughVolumeValue.textContent = e.target.value + '%';
            
            if (passthroughGainNode && passthroughEnabled) {
                passthroughGainNode.gain.setValueAtTime(
                    volume,
                    audioContext ? audioContext.currentTime : 0
                );
            }
        });
        
        // Audio-Ausgabeger√§te beim Start laden
        loadAudioOutputDevices();
        
        // ============================================
        // MIDI SETUP
        // ============================================
        
        let midiAccess = null;
        let currentMidiInput = null;
        let midiEnabled = false;
        let midiNotes = new Map(); // MIDI-Nummer -> { note, velocity, timestamp }
        
        const midiDeviceSelect = document.getElementById('midiDeviceSelect');
        const midiEnabledCheckbox = document.getElementById('midiEnabled');
        const midiStatus = document.getElementById('midiStatus');
        
        // Note-Namen aus MIDI-Nummer
        function midiToNoteName(midi) {
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const octave = Math.floor(midi / 12) - 1;
            const noteName = noteNames[midi % 12];
            const isSharp = noteName.includes('#');
            return { 
                name: noteName, // Vollst√§ndiger Name inkl. # 
                baseName: noteName.replace('#', ''), // Nur Buchstabe
                isSharp: isSharp,
                octave: octave
            };
        }
        
        // MIDI zu internem Note-Format konvertieren (kompatibel mit PitchDetector-Format)
        function midiToNoteObject(midiNum, velocity = 100) {
            const noteInfo = midiToNoteName(midiNum);
            const freq = 440 * Math.pow(2, (midiNum - 69) / 12);
            return {
                midi: midiNum,
                frequency: freq,
                name: noteInfo.name, // z.B. 'C#' oder 'D'
                isSharp: noteInfo.isSharp, // Wichtig f√ºr Farb-Lookup!
                octave: noteInfo.octave,
                full: noteInfo.name + noteInfo.octave, // z.B. 'C#4'
                confidence: velocity / 127,
                source: 'midi'
            };
        }
        
        // MIDI-Ger√§te laden
        async function loadMidiDevices() {
            try {
                midiAccess = await navigator.requestMIDIAccess();
                
                midiDeviceSelect.innerHTML = '<option value="">-- MIDI Ger√§t w√§hlen --</option>';
                
                const inputs = Array.from(midiAccess.inputs.values());
                
                if (inputs.length === 0) {
                    midiStatus.textContent = 'Keine MIDI-Ger√§te gefunden';
                    midiStatus.style.color = '#f66';
                    return;
                }
                
                inputs.forEach((input, index) => {
                    const option = document.createElement('option');
                    option.value = input.id;
                    option.textContent = input.name || `MIDI Input ${index + 1}`;
                    midiDeviceSelect.appendChild(option);
                });
                
                midiStatus.textContent = `${inputs.length} MIDI-Ger√§t(e) gefunden`;
                midiStatus.style.color = '#6f6';
                
                // Auf Ger√§te√§nderungen h√∂ren
                midiAccess.onstatechange = () => loadMidiDevices();
                
            } catch (err) {
                console.error('MIDI-Fehler:', err);
                midiStatus.textContent = 'MIDI nicht verf√ºgbar';
                midiStatus.style.color = '#f66';
            }
        }
        
        // MIDI-Input verbinden
        function connectMidiInput(inputId) {
            // Alte Verbindung trennen
            if (currentMidiInput) {
                currentMidiInput.onmidimessage = null;
                currentMidiInput = null;
            }
            
            if (!inputId || !midiAccess) return;
            
            const input = midiAccess.inputs.get(inputId);
            if (!input) return;
            
            currentMidiInput = input;
            currentMidiInput.onmidimessage = handleMidiMessage;
            
            midiStatus.textContent = `Verbunden: ${input.name}`;
            midiStatus.style.color = '#6f6';
        }
        
        // MIDI-Nachrichten verarbeiten
        function handleMidiMessage(event) {
            const [status, note, velocity] = event.data;
            const command = status >> 4;
            const channel = status & 0xf;
            
            // Note On (command 9) oder Note Off (command 8)
            if (command === 9 && velocity > 0) {
                // Note On
                midiNotes.set(note, {
                    note: midiToNoteObject(note, velocity),
                    velocity: velocity,
                    timestamp: performance.now()
                });
                // Synth Note starten
                startSynthNote(note, velocity);
            } else if (command === 8 || (command === 9 && velocity === 0)) {
                // Note Off
                midiNotes.delete(note);
                // Synth Note stoppen
                stopSynthNote(note);
            }
            
            // Sofort UI updaten wenn MIDI aktiv
            if (midiEnabled) {
                const notes = getMidiNotes();
                const analysis = analyzeIntervals(notes);
                updateUI(notes, analysis);
                applyColors(analysis);
            }
        }
        
        // Aktuelle MIDI-Noten abrufen
        function getMidiNotes() {
            const notes = Array.from(midiNotes.values())
                .map(n => n.note)
                .sort((a, b) => a.midi - b.midi);
            return notes.slice(0, 4); // Max 4 Noten
        }
        
        // Event-Handler
        midiDeviceSelect.addEventListener('change', (e) => {
            connectMidiInput(e.target.value);
        });
        
        midiEnabledCheckbox.addEventListener('change', (e) => {
            midiEnabled = e.target.checked;
            if (!midiEnabled) {
                midiNotes.clear(); // Noten l√∂schen wenn deaktiviert
            }
        });
        
        // ============================================
        // MIDI SYNTHESIZER
        // ============================================
        
        let midiSynthEnabled = false;
        let midiSynthVolume = 0.5;
        let midiSynthContext = null;
        let midiSynthGain = null;
        const midiOscillators = new Map(); // MIDI-Nummer -> { osc, gain }
        
        const midiSynthEnabledCheckbox = document.getElementById('midiSynthEnabled');
        const midiSynthVolumeSlider = document.getElementById('midiSynthVolume');
        const midiSynthVolumeValue = document.getElementById('midiSynthVolumeValue');
        const midiSynthVolumeControl = document.getElementById('midiSynthVolumeControl');
        
        // Synth AudioContext initialisieren
        function initMidiSynth() {
            if (midiSynthContext) return;
            
            midiSynthContext = new AudioContext();
            midiSynthGain = midiSynthContext.createGain();
            midiSynthGain.gain.value = midiSynthVolume;
            midiSynthGain.connect(midiSynthContext.destination);
        }
        
        // Note starten
        function startSynthNote(midiNum, velocity = 100) {
            if (!midiSynthEnabled || !midiSynthContext) return;
            if (midiOscillators.has(midiNum)) return; // Bereits aktiv
            
            const freq = 440 * Math.pow(2, (midiNum - 69) / 12);
            
            // Oszillator erstellen
            const osc = midiSynthContext.createOscillator();
            osc.type = 'triangle'; // Weicher Klang
            osc.frequency.value = freq;
            
            // Eigener Gain f√ºr ADSR
            const noteGain = midiSynthContext.createGain();
            const velGain = (velocity / 127) * 0.3; // Max 0.3 um Clipping zu vermeiden
            
            // Attack
            noteGain.gain.setValueAtTime(0, midiSynthContext.currentTime);
            noteGain.gain.linearRampToValueAtTime(velGain, midiSynthContext.currentTime + 0.02);
            
            osc.connect(noteGain);
            noteGain.connect(midiSynthGain);
            osc.start();
            
            midiOscillators.set(midiNum, { osc, gain: noteGain });
        }
        
        // Note stoppen
        function stopSynthNote(midiNum) {
            const noteData = midiOscillators.get(midiNum);
            if (!noteData) return;
            
            const { osc, gain } = noteData;
            
            // Release
            gain.gain.linearRampToValueAtTime(0, midiSynthContext.currentTime + 0.1);
            
            setTimeout(() => {
                osc.stop();
                osc.disconnect();
                gain.disconnect();
            }, 150);
            
            midiOscillators.delete(midiNum);
        }
        
        // Alle Noten stoppen
        function stopAllSynthNotes() {
            for (const midiNum of midiOscillators.keys()) {
                stopSynthNote(midiNum);
            }
        }
        
        // Event Handler
        midiSynthEnabledCheckbox.addEventListener('change', (e) => {
            midiSynthEnabled = e.target.checked;
            if (midiSynthEnabled) {
                initMidiSynth();
                midiSynthVolumeControl.style.opacity = '1';
                midiSynthVolumeSlider.disabled = false;
            } else {
                stopAllSynthNotes();
                midiSynthVolumeControl.style.opacity = '0.5';
                midiSynthVolumeSlider.disabled = true;
            }
        });
        
        midiSynthVolumeSlider.addEventListener('input', (e) => {
            midiSynthVolume = e.target.value / 100;
            midiSynthVolumeValue.textContent = e.target.value + '%';
            if (midiSynthGain) {
                midiSynthGain.gain.value = midiSynthVolume;
            }
        });
        
        // MIDI beim Start laden
        loadMidiDevices();
        
        startBtn.addEventListener('click', async () => {
            const deviceId = audioSourceSelect.value;
            
            if (!deviceId) {
                alert('Bitte Audioquelle w√§hlen');
                return;
            }
            
            if (currentStream) {
                currentStream.getTracks().forEach(t => t.stop());
                currentStream = null;
                if (audioContext) {
                    audioContext.close();
                    audioContext = null;
                }
                pitchDetector = null;
                percussionDetector = null;
                startBtn.textContent = 'üé§ Starten';
                startBtn.classList.remove('active');
                return;
            }
            
            try {
                currentStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        deviceId: { exact: deviceId },
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });
                
                createAudioChain(currentStream);
                pitchDetector = new PolyphonicPitchDetector(audioContext, analyser);
                
                // Percussion Detector erstellen wenn aktiviert
                if (percussionEnabled) {
                    percussionDetector = new PercussionDetector(audioContext, analyser);
                }
                
                startBtn.textContent = '‚èπ Stoppen';
                startBtn.classList.add('active');
                
            } catch (err) {
                console.error('Audio-Fehler:', err);
                alert('Audio-Zugriff nicht m√∂glich: ' + err.message);
            }
        });
        
        audioSourceSelect.addEventListener('change', async () => {
            if (currentStream) {
                startBtn.click();
                setTimeout(() => startBtn.click(), 100);
            }
        });
        
        // Schema-Auswahl
        document.querySelectorAll('.schema-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.schema-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                activeSchema = btn.dataset.schema;
                
                // Modell sofort ein-/ausblenden je nach Schema
                if (currentModel) {
                    currentModel.visible = (activeSchema !== 'alex');
                }
                
                // Sofort Farben aktualisieren
                refreshVisuals();
                
                // Fallback: Schwarzer Hintergrund wenn keine Analyse vorhanden
                if (!lastAnalysis) {
                    renderer.setClearColor(0x111111);
                    vignetteOverlay.classList.remove('active');
                }
            });
        });
        
        document.getElementById('blendSchemas').addEventListener('change', (e) => {
            blendEnabled = e.target.checked;
            document.getElementById('blendControl').style.display = blendEnabled ? 'block' : 'none';
            refreshVisuals();
        });
        
        document.getElementById('alexDegreeColors').addEventListener('change', (e) => {
            alexDegreeColorsEnabled = e.target.checked;
            refreshVisuals();
        });
        
        document.getElementById('alexGradient').addEventListener('change', (e) => {
            alexGradientEnabled = e.target.checked;
            refreshVisuals();
        });
        
        document.getElementById('alexVignette').addEventListener('change', (e) => {
            alexVignetteEnabled = e.target.checked;
            if (!alexVignetteEnabled) {
                vignetteOverlay.classList.remove('active');
            }
            refreshVisuals();
        });
        
        document.getElementById('blendSlider').addEventListener('input', (e) => {
            blendAmount = parseInt(e.target.value) / 100;
            document.getElementById('blendValue').textContent = e.target.value + '%';
            refreshVisuals();
        });
        
        document.getElementById('scaleSlider').addEventListener('input', (e) => {
            currentScale = parseFloat(e.target.value);
            document.getElementById('scaleValue').textContent = currentScale.toFixed(1);
            if (currentModel) {
                currentModel.scale.set(currentScale, currentScale, currentScale);
            }
        });
        
        document.getElementById('sensitivitySlider').addEventListener('input', (e) => {
            sensitivity = parseFloat(e.target.value);
            document.getElementById('sensitivityValue').textContent = sensitivity.toFixed(2);
        });
        
        document.getElementById('reactionSpeed').addEventListener('input', (e) => {
            const percent = parseInt(e.target.value);
            document.getElementById('reactionSpeedValue').textContent = percent + '%';
            // 0% = smoothing 1.0 (sehr langsam), 100% = smoothing 0 (sofort)
            reactionSmoothing = 1 - (percent / 100);
            // Live-Update des Analysers wenn aktiv
            if (analyser) {
                analyser.smoothingTimeConstant = reactionSmoothing;
            }
        });

        // ============================================
        // MASTER GAIN & EQ CONTROLS
        // ============================================
        
        document.getElementById('masterGain').addEventListener('input', (e) => {
            const db = parseFloat(e.target.value);
            const displayValue = db >= 0 ? '+' + db.toFixed(1) : db.toFixed(1);
            document.getElementById('gainValue').textContent = displayValue + ' dB';
            
            if (masterGainNode) {
                masterGainNode.gain.value = dbToGain(db);
            }
        });
        
        // EQ Controls (3-Band: Low, Mid, High)
        const eqSliders = {
            'eqLow': 'low',
            'eqMid': 'mid',
            'eqHigh': 'high'
        };
        
        Object.entries(eqSliders).forEach(([sliderId, nodeName]) => {
            const slider = document.getElementById(sliderId);
            const valueDisplay = document.getElementById(sliderId + 'Value');
            
            if (slider && valueDisplay) {
                slider.addEventListener('input', (e) => {
                    const db = parseFloat(e.target.value);
                    valueDisplay.textContent = db.toFixed(0);
                    if (eqNodes[nodeName]) {
                        eqNodes[nodeName].gain.value = db;
                    }
                });
            }
        });
        
        document.getElementById('eqReset').addEventListener('click', () => {
            Object.entries(eqSliders).forEach(([sliderId, nodeName]) => {
                const slider = document.getElementById(sliderId);
                const valueDisplay = document.getElementById(sliderId + 'Value');
                
                if (slider && valueDisplay) {
                    slider.value = 0;
                    valueDisplay.textContent = '0';
                    if (eqNodes[nodeName]) {
                        eqNodes[nodeName].gain.value = 0;
                    }
                }
            });
        });

        // ============================================
        // AI BILD GENERIERUNG (ComfyUI Local)
        // ============================================
        
        let aiMode = 'off'; // 'off', 'on', 'overlay'
        let aiAutoGenerate = false;
        let aiIsGenerating = false;
        let aiLastPrompt = '';
        let aiGenerationStart = 0;
        let aiLastGenerationTime = 0;
        let aiLoadedImage = null; // Geladenes Image-Objekt f√ºr Canvas-Rendering
        let aiLastSpeechInput = ''; // Letzte erkannte Spracheingabe
        
        // ============================================
        // MULTI-PROVIDER AI KONFIGURATION
        // ============================================
        
        // Provider & Modell Konfiguration
        const AI_PROVIDERS = {
            local: {
                name: 'Local SD',
                emoji: 'üñ•Ô∏è',
                requiresKey: false,
                requiresUrl: true,
                models: {
                    'local-sd15': { name: 'SD 1.5', emoji: 'üé®', steps: 20, width: 512, height: 512 },
                    'local-sdxl': { name: 'SDXL', emoji: 'üñºÔ∏è', steps: 25, width: 1024, height: 1024 },
                    'local-turbo': { name: 'Turbo', emoji: '‚ö°', steps: 4, width: 512, height: 512, cfg: 1 }
                }
            }
        };
        
        // Local SD URL (aus localStorage)
        let aiApiKeys = {
            localUrl: localStorage.getItem('ai_local_url') || 'http://127.0.0.1:8188'
        };
        
        // Aktiver Provider & Modell
        let aiCurrentProvider = 'local';
        let aiCurrentModel = 'local-sd15';
        let aiMixMode = false;
        
        // Buffer-Modus Variablen
        let aiBufferMode = false;
        
        // Buffer pro Modell (dynamisch f√ºr alle Provider/Modelle)
        let aiModelBuffers = {};
        let aiModelGenerations = {};
        
        // Initialisiere Buffer f√ºr alle Modelle
        function initModelBuffers() {
            Object.keys(AI_PROVIDERS).forEach(provider => {
                Object.keys(AI_PROVIDERS[provider].models).forEach(model => {
                    const key = `${provider}:${model}`;
                    aiModelBuffers[key] = [];
                    aiModelGenerations[key] = 0;
                });
            });
        }
        initModelBuffers();
        
        // Gemeinsamer kombinierter Buffer f√ºr Mix-Modus
        let aiImageBuffer = []; // Wird dynamisch aus Modell-Buffern kombiniert
        let aiBufferSize = 24;
        let aiFps = 24; // 0 = off, 1, 12, 24
        let aiBeatSync = false; // Bildwechsel bei Beat
        let aiCrossfadeEnabled = false;
        let aiParallelGen = 1;
        let aiActiveGenerations = 0;
        let aiCurrentGenPrompt = ''; // Aktuell generierter Prompt
        let aiDisplayTimer = null;
        let aiCurrentBufferIndex = 0;
        let aiUsedPrompts = new Set(); // Verhindert doppelte Prompts im Buffer
        let aiImageIdCounter = 0; // Eindeutige ID f√ºr jedes Bild
        
        // Crossfade Variablen
        let aiCrossfadeDuration = 0.5; // Sekunden
        let aiCurrentImage = null; // Aktuell angezeigtes Bild
        let aiNextImage = null; // N√§chstes Bild (f√ºr Crossfade)
        let aiCrossfadeProgress = 1; // 0-1, 1 = kein Crossfade aktiv
        let aiCrossfadeStartTime = 0;
        let aiActiveThumbId = null; // ID des aktiven Thumbnails
        
        const aiImageContainer = document.getElementById('aiImageContainer');
        const aiImage = document.getElementById('aiImage');
        const aiImageStatus = document.getElementById('aiImageStatus');
        const aiImagePreview = document.getElementById('aiImagePreview');
        const aiStats = document.getElementById('aiStats');
        const aiGenerateBtn = document.getElementById('aiGenerateBtn');
        const aiPromptInput = document.getElementById('aiPromptInput');
        const aiAutoGenerateCheckbox = document.getElementById('aiAutoGenerate');
        
        // Panel Minimize Funktion
        document.querySelectorAll('.panel h3').forEach(header => {
            header.addEventListener('click', () => {
                const panel = header.closest('.panel');
                panel.classList.toggle('minimized');
                // Zustand im localStorage speichern
                const panelId = panel.id;
                if (panelId) {
                    localStorage.setItem('panel_' + panelId, panel.classList.contains('minimized') ? 'min' : 'max');
                }
            });
        });
        
        // Panel-Zust√§nde aus localStorage wiederherstellen
        ['panelFarbschema', 'panel3DModell', 'panelEffekte', 'panelAiBild'].forEach(id => {
            const state = localStorage.getItem('panel_' + id);
            if (state === 'min') {
                const panel = document.getElementById(id);
                if (panel) panel.classList.add('minimized');
            }
        });
        
        // Mode Buttons
        document.querySelectorAll('.ai-mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.ai-mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                aiMode = btn.dataset.aimode;
                updateAiDisplay();
            });
        });
        
        // Auto-Generate Checkbox
        aiAutoGenerateCheckbox.addEventListener('change', (e) => {
            aiAutoGenerate = e.target.checked;
        });
        
        // Buffer-Modus UI
        const aiBufferModeCheckbox = document.getElementById('aiBufferMode');
        const aiBufferSettings = document.getElementById('aiBufferSettings');
        const aiBufferSizeSlider = document.getElementById('aiBufferSize');
        const aiBufferSizeValue = document.getElementById('aiBufferSizeValue');
        const aiParallelGenSlider = document.getElementById('aiParallelGen');
        const aiParallelGenValue = document.getElementById('aiParallelGenValue');
        const aiBufferStatus = document.getElementById('aiBufferStatus');
        const aiBufferThumbs = document.getElementById('aiBufferThumbs');
        const aiCrossfadeDurationSlider = document.getElementById('aiCrossfadeDuration');
        const aiCrossfadeDurationValue = document.getElementById('aiCrossfadeDurationValue');
        const aiCrossfadeEnabledCheckbox = document.getElementById('aiCrossfadeEnabled');
        const aiCrossfadeSettings = document.getElementById('aiCrossfadeSettings');
        
        // FPS Buttons
        document.querySelectorAll('[data-fps]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-fps]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                aiFps = parseInt(btn.dataset.fps);
                if (!aiBeatSync) restartDisplayTimer();
            });
        });
        
        // Model-Tabs
        document.querySelectorAll('.ai-model-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.ai-model-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                aiCurrentModel = tab.dataset.model;
                updateModelStatus();
                updateBufferThumbnails();
                console.log('AI: Modell gewechselt zu', aiCurrentModel);
            });
        });
        
        // Beat-Sync Checkbox
        const aiBeatSyncCheckbox = document.getElementById('aiBeatSync');
        aiBeatSyncCheckbox.addEventListener('change', (e) => {
            aiBeatSync = e.target.checked;
            if (aiBeatSync) {
                // FPS Timer stoppen bei Beat-Sync
                if (aiDisplayTimer) {
                    clearInterval(aiDisplayTimer);
                    aiDisplayTimer = null;
                }
                console.log('AI: Beat-Sync aktiviert');
            } else {
                // FPS Timer wieder starten
                restartDisplayTimer();
                console.log('AI: Beat-Sync deaktiviert');
            }
        });
        
        // Crossfade Enable Checkbox
        aiCrossfadeEnabledCheckbox.addEventListener('change', (e) => {
            aiCrossfadeEnabled = e.target.checked;
            aiCrossfadeSettings.style.display = aiCrossfadeEnabled ? 'block' : 'none';
        });
        
        // Crossfade Duration Slider
        aiCrossfadeDurationSlider.addEventListener('input', (e) => {
            aiCrossfadeDuration = parseFloat(e.target.value);
            aiCrossfadeDurationValue.textContent = aiCrossfadeDuration + 's';
        });
        
        aiBufferModeCheckbox.addEventListener('change', (e) => {
            aiBufferMode = e.target.checked;
            aiBufferSettings.style.display = aiBufferMode ? 'block' : 'none';
            if (aiBufferMode) {
                // AI-Modus automatisch auf 'on' setzen wenn Buffer aktiviert
                if (aiMode === 'off') {
                    aiMode = 'on';
                    document.querySelectorAll('.ai-mode-btn[data-aimode]').forEach(b => b.classList.remove('active'));
                    document.querySelector('.ai-mode-btn[data-aimode="on"]')?.classList.add('active');
                    console.log('AI: Mode automatisch auf "on" gesetzt');
                }
                startBufferSystem();
            } else {
                stopBufferSystem();
            }
        });
        
        aiBufferSizeSlider.addEventListener('input', (e) => {
            aiBufferSize = parseInt(e.target.value);
            aiBufferSizeValue.textContent = aiBufferSize;
            updateBufferStatus();
        });
        
        function restartDisplayTimer() {
            if (aiDisplayTimer) {
                clearInterval(aiDisplayTimer);
                aiDisplayTimer = null;
            }
            console.log('restartDisplayTimer: bufferMode=', aiBufferMode, 'fps=', aiFps, 'beatSync=', aiBeatSync);
            // Kein Timer bei Beat-Sync oder FPS=0
            if (aiBufferMode && aiFps > 0 && !aiBeatSync) {
                const interval = 1000 / aiFps;
                aiDisplayTimer = setInterval(displayNextBufferImage, interval);
                console.log('AI: Display Timer gestartet mit', aiFps, 'fps (', interval, 'ms)');
            }
        }
        
        aiParallelGenSlider.addEventListener('input', (e) => {
            aiParallelGen = parseInt(e.target.value);
            aiParallelGenValue.textContent = aiParallelGen;
        });
        
        // ============================================
        // PROVIDER & MODEL TAB HANDLERS
        // ============================================
        
        // Provider-Tabs
        document.querySelectorAll('.ai-provider-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const provider = tab.dataset.provider;
                
                if (provider === 'settings') {
                    // Toggle Settings Panel
                    const settingsPanel = document.getElementById('aiSettingsPanel');
                    const modelSelector = document.getElementById('aiModelSelector');
                    if (settingsPanel.style.display === 'none') {
                        settingsPanel.style.display = 'block';
                        modelSelector.style.display = 'none';
                        tab.classList.add('active');
                    } else {
                        settingsPanel.style.display = 'none';
                        modelSelector.style.display = 'block';
                        tab.classList.remove('active');
                    }
                    return;
                }
                
                // Provider wechseln
                document.querySelectorAll('.ai-provider-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Mix-Modus aktivieren/deaktivieren
                if (provider === 'mix') {
                    aiMixMode = true;
                    // Provider bleibt beim letzten aktiven f√ºr Generierung
                } else {
                    aiMixMode = false;
                    aiCurrentProvider = provider;
                }
                
                // Settings Panel verstecken
                document.getElementById('aiSettingsPanel').style.display = 'none';
                document.getElementById('aiModelSelector').style.display = 'block';
                document.querySelector('.ai-provider-tab[data-provider="settings"]').classList.remove('active');
                
                // Modell-Gruppe anzeigen
                document.querySelectorAll('.ai-model-group').forEach(g => g.style.display = 'none');
                const modelGroup = document.querySelector(`.ai-model-group[data-provider="${provider}"]`);
                if (modelGroup) {
                    modelGroup.style.display = 'block';
                    // Erstes Modell des Providers ausw√§hlen (nur wenn nicht Mix)
                    if (provider !== 'mix') {
                        const firstModel = modelGroup.querySelector('.ai-model-tab');
                        if (firstModel) {
                            modelGroup.querySelectorAll('.ai-model-tab').forEach(m => m.classList.remove('active'));
                            firstModel.classList.add('active');
                            aiCurrentModel = firstModel.dataset.model;
                        }
                    }
                }
                
                // Status aktualisieren
                updateModelStatus();
                updateBufferThumbnails();
                console.log('AI: Provider gewechselt zu', provider, aiMixMode ? '(Mix-Modus)' : ('/ ' + aiCurrentModel));
            });
        });
        
        // Model-Tabs (innerhalb der Provider-Gruppen)
        document.querySelectorAll('.ai-model-group .ai-model-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const group = tab.closest('.ai-model-group');
                group.querySelectorAll('.ai-model-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                aiCurrentModel = tab.dataset.model;
                updateModelStatus();
                updateBufferThumbnails();
                console.log('AI: Modell gewechselt zu', aiCurrentModel);
            });
        });
        
        // Settings speichern
        document.getElementById('saveApiKeys').addEventListener('click', () => {
            const localUrl = document.getElementById('localSdUrl').value.trim();
            
            if (localUrl) localStorage.setItem('ai_local_url', localUrl);
            else localStorage.removeItem('ai_local_url');
            
            aiApiKeys.localUrl = localUrl || 'http://127.0.0.1:8188';
            
            checkLocalSdConnection();
            document.getElementById('apiKeyStatus').textContent = '‚úÖ Gespeichert!';
            setTimeout(() => {
                document.getElementById('apiKeyStatus').textContent = '';
            }, 2000);
        });
        
        // Settings laden
        function loadApiKeys() {
            document.getElementById('localSdUrl').value = aiApiKeys.localUrl;
            checkLocalSdConnection();
        }
        
        // Local SD Verbindung pr√ºfen
        async function checkLocalSdConnection() {
            const statusEl = document.getElementById('localSdStatus');
            if (!statusEl) return;
            
            statusEl.textContent = 'üñ•Ô∏è Verbinde...';
            statusEl.style.color = '#888';
            
            try {
                const response = await fetch(`${aiApiKeys.localUrl}/system_stats`, {
                    method: 'GET',
                    signal: AbortSignal.timeout(3000)
                });
                
                if (response.ok) {
                    const stats = await response.json();
                    const vram = stats.system?.vram ? Math.round(stats.system.vram.total / 1024 / 1024 / 1024) + 'GB' : '?';
                    statusEl.textContent = `‚úÖ ComfyUI verbunden (${vram} VRAM)`;
                    statusEl.style.color = '#4f4';
                    document.querySelector('.ai-provider-tab[data-provider="local"]')?.classList.add('has-key');
                } else {
                    throw new Error('API nicht erreichbar');
                }
            } catch (error) {
                statusEl.textContent = '‚ùå Nicht verbunden - ComfyUI starten';
                statusEl.style.color = '#f66';
                document.querySelector('.ai-provider-tab[data-provider="local"]')?.classList.remove('has-key');
            }
        }
        
        // Beim Start laden
        setTimeout(loadApiKeys, 100);
        setTimeout(updateModelStatus, 150);
        
        // ComfyUI Start Button - kopiert Kommando oder zeigt Anleitung
        document.getElementById('startComfyBtn')?.addEventListener('click', async () => {
            const cmd = 'cd ~/Documents/ComfyUI && eval "$(pyenv init -)" && python main.py --enable-cors-header';
            try {
                await navigator.clipboard.writeText(cmd);
                document.getElementById('localSdStatus').textContent = '‚úÖ Kommando kopiert! In Terminal einf√ºgen.';
                document.getElementById('localSdStatus').style.color = '#4f4';
            } catch (e) {
                alert('Terminal √∂ffnen und einf√ºgen:\n\n' + cmd);
            }
            // Nach 5s erneut Verbindung pr√ºfen
            setTimeout(checkLocalSdConnection, 5000);
        });
        
        // Hilfsfunktion: Aktuellen Buffer-Key ermitteln
        function getCurrentBufferKey() {
            return `${aiCurrentProvider}:${aiCurrentModel}`;
        }
        
        // Hilfsfunktion: Modell-Info abrufen
        function getModelInfo(provider, model) {
            if (AI_PROVIDERS[provider] && AI_PROVIDERS[provider].models[model]) {
                return AI_PROVIDERS[provider].models[model];
            }
            return { name: model, emoji: 'üñºÔ∏è' };
        }
        
        function updateBufferStatus() {
            if (aiBufferStatus) {
                const ready = aiImageBuffer.length;
                const generating = aiActiveGenerations;
                
                // Spinner anzeigen wenn am Generieren
                const spinner = generating > 0 ? '‚è≥ ' : '';
                aiBufferStatus.textContent = `${spinner}Buffer: ${ready}/${aiBufferSize}` + (generating > 0 ? ` (+${generating})` : '');
                aiBufferStatus.style.color = generating > 0 ? '#4af' : (ready >= aiBufferSize ? '#4f4' : (ready > 0 ? '#ff0' : '#f66'));
            }
            
            updateBufferThumbnails();
            
            // Auto-Generierung: N√§chstes Bild starten wenn Buffer nicht voll
            if (aiAutoGenerate && aiBufferMode && aiMode !== 'off') {
                const prompt = aiPromptInput.value.trim() || window.aiLastSpeechInput || '';
                if (prompt.length > 2) {
                    triggerContinuousGeneration(prompt);
                }
            }
        }
        
        function updateBufferThumbnails() {
            if (!aiBufferThumbs) return;
            
            // Buffer aktualisieren
            updateCombinedBuffer();
            
            // Thumbnails f√ºr Buffer-Bilder erstellen
            aiBufferThumbs.innerHTML = '';
            
            // Z√§hler anzeigen (zeigt aktiven Modell-Buffer oder kombinierten)
            const counter = document.createElement('div');
            counter.className = 'ai-thumb-counter';
            const bufferKey = getCurrentBufferKey();
            const currentBuffer = aiModelBuffers[bufferKey] || [];
            const displayCount = aiMixMode ? aiImageBuffer.length : currentBuffer.length;
            const modelInfo = getModelInfo(aiCurrentProvider, aiCurrentModel);
            counter.textContent = aiMixMode ? `‚¨Ü${aiImageBuffer.length}` : `${modelInfo.emoji}${displayCount}`;
            counter.style.cssText = 'font-size: 9px; color: #888; padding: 2px 6px; background: #222; border-radius: 3px; display: flex; align-items: center; justify-content: center; min-width: 36px; height: 36px;';
            if (displayCount >= aiBufferSize) counter.style.color = '#4f4';
            else if (displayCount > 0) counter.style.color = '#ff0';
            else counter.style.color = '#f66';
            aiBufferThumbs.appendChild(counter);
            
            // Fertige Bilder als Thumbnails
            aiImageBuffer.forEach((item, index) => {
                const thumb = document.createElement('img');
                thumb.className = 'ai-thumb';
                thumb.src = item.image.src;
                const itemInfo = getModelInfo(item.provider, item.model);
                thumb.title = `${itemInfo.emoji} ${item.prompt}`;
                thumb.dataset.id = item.id;
                
                if (item.id === aiActiveThumbId) {
                    thumb.classList.add('active');
                }
                
                // Klick zum sofortigen Anzeigen
                thumb.addEventListener('click', () => {
                    startCrossfade(item.image, item.id);
                    aiStats.textContent = `${itemInfo.emoji} "${item.prompt.substring(0, 18)}..." | ${item.time}s`;
                });
                
                aiBufferThumbs.appendChild(thumb);
            });
            
            // Spinner-Platzhalter f√ºr aktive Generierungen
            for (let i = 0; i < aiActiveGenerations; i++) {
                const placeholder = document.createElement('div');
                placeholder.className = 'ai-thumb ai-thumb-loading';
                const modelInfo = getModelInfo(aiCurrentProvider, aiCurrentModel);
                placeholder.innerHTML = `<span class="ai-spinner"></span>`;
                placeholder.title = `${modelInfo.emoji} ${aiCurrentGenPrompt || 'Generiere...'}`;
                aiBufferThumbs.appendChild(placeholder);
            }
        }
        
        function startCrossfade(newImage, imageId = null) {
            if (!newImage) return;
            
            // Wenn kein aktuelles Bild oder Crossfade deaktiviert, direkt anzeigen
            if (!aiCurrentImage || !aiCrossfadeEnabled) {
                aiCurrentImage = newImage;
                aiLoadedImage = newImage;
                aiActiveThumbId = imageId;
                aiCrossfadeProgress = 1;
                aiNextImage = null;
                updateBufferThumbnails();
                return;
            }
            
            // Crossfade starten
            aiNextImage = newImage;
            aiActiveThumbId = imageId;
            aiCrossfadeProgress = 0;
            aiCrossfadeStartTime = performance.now();
            updateBufferThumbnails();
            
            console.log('AI: Crossfade gestartet, Dauer:', aiCrossfadeDuration, 's');
        }
        
        function updateCrossfade() {
            if (aiCrossfadeProgress >= 1 || !aiNextImage) return;
            
            const elapsed = (performance.now() - aiCrossfadeStartTime) / 1000;
            aiCrossfadeProgress = Math.min(1, elapsed / aiCrossfadeDuration);
            
            // Ease-in-out
            const eased = aiCrossfadeProgress < 0.5 
                ? 2 * aiCrossfadeProgress * aiCrossfadeProgress 
                : 1 - Math.pow(-2 * aiCrossfadeProgress + 2, 2) / 2;
            
            // Wenn fertig, Bilder tauschen
            if (aiCrossfadeProgress >= 1) {
                aiCurrentImage = aiNextImage;
                aiLoadedImage = aiNextImage;
                aiNextImage = null;
                console.log('AI: Crossfade abgeschlossen');
            }
            
            return eased;
        }
        
        function startBufferSystem() {
            console.log('AI Buffer: System gestartet');
            // Alle Modell-Buffer leeren
            Object.keys(aiModelBuffers).forEach(model => {
                aiModelBuffers[model] = [];
                aiModelGenerations[model] = 0;
            });
            aiImageBuffer = [];
            aiUsedPrompts.clear();
            updateModelStatus();
            updateBufferStatus();
            
            // Display Timer starten
            restartDisplayTimer();
        }
        
        function stopBufferSystem() {
            console.log('AI Buffer: System gestoppt');
            if (aiDisplayTimer) {
                clearInterval(aiDisplayTimer);
                aiDisplayTimer = null;
            }
            aiActiveGenerations = 0;
            Object.keys(aiModelGenerations).forEach(m => aiModelGenerations[m] = 0);
            updateModelStatus();
            updateBufferStatus();
        }
        
        // Kombiniert alle Modell-Buffer f√ºr Mix-Modus
        function updateCombinedBuffer() {
            const bufferKey = getCurrentBufferKey();
            
            if (aiMixMode) {
                // Alle Buffer zusammenf√ºhren und mischen
                let combined = [];
                Object.keys(aiModelBuffers).forEach(key => {
                    const [provider, model] = key.split(':');
                    aiModelBuffers[key].forEach(item => {
                        combined.push({...item, provider: provider, model: model});
                    });
                });
                // Zuf√§llig mischen
                combined.sort(() => Math.random() - 0.5);
                aiImageBuffer = combined;
            } else {
                // Nur aktives Modell
                const currentBuffer = aiModelBuffers[bufferKey] || [];
                aiImageBuffer = currentBuffer.map(item => ({...item, provider: aiCurrentProvider, model: aiCurrentModel}));
            }
        }
        
        // Aktualisiert die Status-Anzeige pro Modell (dynamisch generiert)
        function updateModelStatus() {
            const statusContainer = document.getElementById('aiModelBufferStatus');
            const mixStats = document.getElementById('aiMixStats');
            if (!statusContainer) return;
            
            statusContainer.innerHTML = '';
            
            if (aiMixMode) {
                // Mix-Modus: √úbersicht aller Buffer
                let totalCount = 0;
                let bufferList = [];
                
                Object.keys(AI_PROVIDERS).forEach(provider => {
                    const providerConfig = AI_PROVIDERS[provider];
                    Object.keys(providerConfig.models).forEach(model => {
                        const bufferKey = `${provider}:${model}`;
                        const count = aiModelBuffers[bufferKey] ? aiModelBuffers[bufferKey].length : 0;
                        if (count > 0) {
                            const modelInfo = providerConfig.models[model];
                            bufferList.push(`${modelInfo.emoji} ${count}`);
                            totalCount += count;
                        }
                    });
                });
                
                // Mix Stats im Mix-Panel aktualisieren
                if (mixStats) {
                    if (bufferList.length > 0) {
                        mixStats.innerHTML = bufferList.join(' ¬∑ ') + `<div style="margin-top: 4px; color: #4f4;">Gesamt: ${totalCount} Bilder</div>`;
                    } else {
                        mixStats.innerHTML = '<span style="color: #666;">Keine Bilder in Buffern</span>';
                    }
                }
                
                // Status-Anzeige: Gesamt
                statusContainer.innerHTML = `<span style="color: #4af;">üåÄ ${totalCount} Bilder kombiniert</span>`;
                
            } else {
                // Normaler Modus: nur aktuelles Modell
                const bufferKey = getCurrentBufferKey();
                const count = aiModelBuffers[bufferKey] ? aiModelBuffers[bufferKey].length : 0;
                const gen = aiModelGenerations[bufferKey] || 0;
                const modelInfo = getModelInfo(aiCurrentProvider, aiCurrentModel);
                
                let statusText = `${modelInfo.emoji} ${modelInfo.name}: ${count} Bilder`;
                if (gen > 0) statusText += ` (+${gen} generieren)`;
                
                const statusSpan = document.createElement('span');
                statusSpan.style.color = count > 0 ? '#4f4' : '#888';
                statusSpan.textContent = statusText;
                statusContainer.appendChild(statusSpan);
            }
            
            // Tabs aktualisieren (gelber Rand wenn Bilder vorhanden)
            document.querySelectorAll('.ai-model-group .ai-model-tab').forEach(tab => {
                const model = tab.dataset.model;
                const group = tab.closest('.ai-model-group');
                const provider = group ? group.dataset.provider : aiCurrentProvider;
                const bufferKey = `${provider}:${model}`;
                const count = aiModelBuffers[bufferKey] ? aiModelBuffers[bufferKey].length : 0;
                tab.classList.toggle('has-images', count > 0);
            });
            
            // Provider-Tabs: Markieren wenn mindestens ein Modell Bilder hat
            document.querySelectorAll('.ai-provider-tab').forEach(tab => {
                const provider = tab.dataset.provider;
                if (provider === 'settings' || provider === 'mix') return;
                
                let hasImages = false;
                const providerConfig = AI_PROVIDERS[provider];
                if (providerConfig) {
                    Object.keys(providerConfig.models).forEach(model => {
                        const bufferKey = `${provider}:${model}`;
                        if (aiModelBuffers[bufferKey] && aiModelBuffers[bufferKey].length > 0) {
                            hasImages = true;
                        }
                    });
                }
                tab.classList.toggle('has-images', hasImages);
            });
        }
        
        function displayNextBufferImage() {
            // Buffer aktualisieren
            updateCombinedBuffer();
            
            console.log('displayNextBufferImage: aiMode=', aiMode, 'buffer length=', aiImageBuffer.length);
            
            if (aiMode === 'off' || aiImageBuffer.length === 0) return;
            
            // N√§chstes Bild aus Buffer holen (aber nicht entfernen - bleibt als Thumbnail)
            const item = aiImageBuffer[0];
            if (item && item.image) {
                // Crossfade zum n√§chsten Bild starten
                startCrossfade(item.image, item.id);
                
                // Preview aktualisieren
                aiImagePreview.innerHTML = `<img src="${item.image.src}" alt="AI Preview">`;
                aiStats.textContent = `"${item.prompt.substring(0, 20)}..." | ${item.time}s`;
                
                // Bild nach vorne rotieren (ans Ende des Buffers)
                aiImageBuffer.push(aiImageBuffer.shift());
                
                console.log('AI Buffer: Crossfade zu n√§chstem Bild, Buffer:', aiImageBuffer.length);
            }
            
            updateBufferStatus();
        }
        
        async function generateBufferImage(prompt, retryCount = 0, provider = null, model = null) {
            const targetProvider = provider || aiCurrentProvider;
            const targetModel = model || aiCurrentModel;
            const bufferKey = `${targetProvider}:${targetModel}`;
            const MAX_RETRIES = 2;
            const RETRY_DELAY = 5000;
            
            if (aiActiveGenerations >= aiParallelGen) {
                console.log('AI Buffer: Max parallele Generierungen erreicht');
                return;
            }
            
            const modelBuffer = aiModelBuffers[bufferKey] || [];
            if (modelBuffer.length >= aiBufferSize) {
                console.log('AI Buffer: Buffer voll f√ºr', bufferKey);
                return;
            }
            
            // Prompt schon in Verwendung?
            const promptKey = prompt + bufferKey;
            if (aiUsedPrompts.has(promptKey) && retryCount === 0) {
                // Variation mit Seed erzwingen
            }
            if (retryCount === 0) aiUsedPrompts.add(promptKey);
            
            aiActiveGenerations++;
            if (!aiModelGenerations[bufferKey]) aiModelGenerations[bufferKey] = 0;
            aiModelGenerations[bufferKey]++;
            aiCurrentGenPrompt = prompt;
            updateModelStatus();
            updateBufferStatus();
            
            const startTime = performance.now();
            const seed = Math.floor(Math.random() * 999999);
            
            console.log('AI Buffer: Generiere', targetProvider, '/', targetModel, 'Bild f√ºr:', prompt, retryCount > 0 ? `(Retry ${retryCount})` : '');
            
            try {
                let imageResult;
                
                // Local ComfyUI Generierung
                imageResult = await generateLocal(prompt, targetModel, seed);
                
                const generationTime = ((performance.now() - startTime) / 1000).toFixed(1);
                
                // Zum Buffer hinzuf√ºgen
                const imageId = ++aiImageIdCounter;
                if (!aiModelBuffers[bufferKey]) aiModelBuffers[bufferKey] = [];
                aiModelBuffers[bufferKey].push({
                    image: imageResult,
                    prompt: prompt,
                    time: generationTime,
                    id: imageId,
                    provider: targetProvider,
                    model: targetModel
                });
                
                console.log('AI Buffer:', bufferKey, 'Bild fertig in', generationTime, 's, Buffer:', aiModelBuffers[bufferKey].length);
                
                updateCombinedBuffer();
                
                if (aiImageBuffer.length === 1 && !aiCurrentImage) {
                    displayNextBufferImage();
                }
                
                updateModelStatus();
                updateBufferStatus();
                
            } catch (error) {
                console.warn('AI Buffer: Fehler (Versuch', retryCount + 1, '):', error.message);
                
                if (retryCount < MAX_RETRIES) {
                    aiActiveGenerations--;
                    aiModelGenerations[bufferKey]--;
                    updateModelStatus();
                    updateBufferStatus();
                    const waitTime = RETRY_DELAY * (retryCount + 1);
                    console.log('AI Buffer: Warte', waitTime / 1000, 's vor Retry...');
                    await new Promise(r => setTimeout(r, waitTime));
                    return generateBufferImage(prompt, retryCount + 1, targetProvider, targetModel);
                } else {
                    console.error('AI Buffer: Alle Retries fehlgeschlagen f√ºr:', prompt);
                    aiUsedPrompts.delete(promptKey);
                    aiStats.textContent = '‚ö† Generierung fehlgeschlagen';
                }
            }
            
            aiActiveGenerations--;
            aiModelGenerations[bufferKey]--;
            if (aiActiveGenerations === 0) aiCurrentGenPrompt = '';
            updateModelStatus();
            updateBufferStatus();
        }
        
        // ============================================
        // COMFYUI GENERIERUNGSFUNKTION
        // ============================================
        
        // ComfyUI Workflow-basierte Generierung
        async function generateLocal(prompt, model, seed) {
            const modelConfig = AI_PROVIDERS.local.models[model] || {};
            const steps = modelConfig.steps || 20;
            const width = modelConfig.width || 512;
            const height = modelConfig.height || 512;
            const cfg = modelConfig.cfg || 7;
            
            // ComfyUI Workflow f√ºr txt2img
            const workflow = {
                "3": {
                    "class_type": "KSampler",
                    "inputs": {
                        "seed": seed,
                        "steps": steps,
                        "cfg": cfg,
                        "sampler_name": "euler",
                        "scheduler": "normal",
                        "denoise": 1,
                        "model": ["4", 0],
                        "positive": ["6", 0],
                        "negative": ["7", 0],
                        "latent_image": ["5", 0]
                    }
                },
                "4": {
                    "class_type": "CheckpointLoaderSimple",
                    "inputs": {
                        "ckpt_name": "v1-5-pruned.safetensors"
                    }
                },
                "5": {
                    "class_type": "EmptyLatentImage",
                    "inputs": {
                        "width": width,
                        "height": height,
                        "batch_size": 1
                    }
                },
                "6": {
                    "class_type": "CLIPTextEncode",
                    "inputs": {
                        "text": prompt,
                        "clip": ["4", 1]
                    }
                },
                "7": {
                    "class_type": "CLIPTextEncode",
                    "inputs": {
                        "text": "blurry, bad quality, worst quality",
                        "clip": ["4", 1]
                    }
                },
                "8": {
                    "class_type": "VAEDecode",
                    "inputs": {
                        "samples": ["3", 0],
                        "vae": ["4", 2]
                    }
                },
                "9": {
                    "class_type": "SaveImage",
                    "inputs": {
                        "filename_prefix": "synesthesia",
                        "images": ["8", 0]
                    }
                }
            };
            
            // Workflow an ComfyUI senden
            const queueResponse = await fetch(`${aiApiKeys.localUrl}/prompt`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt: workflow })
            });
            
            if (!queueResponse.ok) {
                throw new Error(`ComfyUI Queue Fehler: ${queueResponse.status}`);
            }
            
            const { prompt_id } = await queueResponse.json();
            
            // Auf Fertigstellung warten (polling)
            let attempts = 0;
            const maxAttempts = 120; // 60 Sekunden max
            
            while (attempts < maxAttempts) {
                await new Promise(r => setTimeout(r, 500));
                
                const historyResponse = await fetch(`${aiApiKeys.localUrl}/history/${prompt_id}`);
                const history = await historyResponse.json();
                
                if (history[prompt_id]) {
                    const outputs = history[prompt_id].outputs;
                    if (outputs && outputs["9"] && outputs["9"].images && outputs["9"].images[0]) {
                        const imageInfo = outputs["9"].images[0];
                        const imageUrl = `${aiApiKeys.localUrl}/view?filename=${imageInfo.filename}&subfolder=${imageInfo.subfolder || ''}&type=${imageInfo.type || 'output'}`;
                        
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = () => reject(new Error('Image load failed'));
                            img.src = imageUrl;
                        });
                        
                        return img;
                    }
                }
                attempts++;
            }
            
            throw new Error('ComfyUI: Timeout beim Warten auf Bild');
        }
        
        // Kontinuierliche Auto-Generierung
        function triggerContinuousGeneration(prompt) {
            // Local Buffer f√ºllen (nur wenn verbunden)
            const localTab = document.querySelector('.ai-provider-tab[data-provider="local"]');
            if (localTab && localTab.classList.contains('has-key')) {
                const localBuffer = aiModelBuffers['local:local-sd15'] || [];
                if (localBuffer.length < aiBufferSize && aiActiveGenerations < aiParallelGen * 2) {
                    generateBufferImage(prompt, 0, 'local', 'local-sd15');
                }
            }
        }
        
        // Manual Generate Button
        function triggerGeneration() {
            // Textfeld hat Priorit√§t, dann Spracheingabe
            const text = (aiPromptInput.value.trim()) || (window.aiLastSpeechInput || '');
            if (text && text.length > 0) {
                if (aiBufferMode) {
                    // Im Buffer-Modus: Local ComfyUI nutzen
                    const localTab = document.querySelector('.ai-provider-tab[data-provider="local"]');
                    
                    if (localTab && localTab.classList.contains('has-key')) {
                        for (let i = 0; i < aiParallelGen; i++) {
                            setTimeout(() => generateBufferImage(text, 0, 'local', 'local-sd15'), i * 1000);
                        }
                    } else {
                        aiStats.textContent = '‚ö† ComfyUI nicht verbunden!';
                    }
                } else {
                    generateAiImage(text);
                }
            } else {
                aiStats.textContent = '‚ö† Keine Eingabe';
            }
        }
        
        aiGenerateBtn.addEventListener('click', triggerGeneration);
        
        // Enter im Textfeld generiert auch
        aiPromptInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                triggerGeneration();
            }
        });
        
        
        // Clear Prompt Button
        document.getElementById('aiClearPrompt')?.addEventListener('click', () => {
            aiPromptInput.value = '';
            window.aiLastSpeechInput = '';
            const aiCurrentInput = document.getElementById('aiCurrentInput');
            if (aiCurrentInput) aiCurrentInput.textContent = 'üé§ -';
            console.log('AI: Prompt gel√∂scht');
        });
        
        // Textfilter Checkboxen
        document.getElementById('aiFilterNouns')?.addEventListener('change', (e) => {
            aiFilterNouns = e.target.checked;
            console.log('AI Filter: Substantive', aiFilterNouns ? 'aktiviert' : 'deaktiviert');
        });
        
        document.getElementById('aiFilterVerbs')?.addEventListener('change', (e) => {
            aiFilterVerbs = e.target.checked;
            console.log('AI Filter: Verben', aiFilterVerbs ? 'aktiviert' : 'deaktiviert');
        });
        
        document.getElementById('aiFilterAdj')?.addEventListener('change', (e) => {
            aiFilterAdj = e.target.checked;
            console.log('AI Filter: Adjektive', aiFilterAdj ? 'aktiviert' : 'deaktiviert');
        });
        function updateAiDisplay() {
            if (aiMode === 'off') {
                aiImageContainer.style.display = 'none';
                aiImageContainer.classList.remove('overlay-mode', 'on-mode');
            } else if (aiMode === 'overlay') {
                aiImageContainer.style.display = 'block';
                aiImageContainer.classList.add('overlay-mode');
                aiImageContainer.classList.remove('on-mode');
            } else if (aiMode === 'on') {
                aiImageContainer.style.display = 'block';
                aiImageContainer.classList.remove('overlay-mode');
                aiImageContainer.classList.add('on-mode');
            }
        }
        
        async function generateAiImage(prompt) {
            if (aiIsGenerating) {
                console.log('AI: Bereits am Generieren...');
                return;
            }
            
            if (prompt === aiLastPrompt) {
                console.log('AI: Gleicher Prompt, √ºberspringe');
                return;
            }
            
            aiIsGenerating = true;
            aiLastPrompt = prompt;
            aiGenerationStart = performance.now();
            
            aiGenerateBtn.disabled = true;
            aiGenerateBtn.textContent = '‚è≥ Generiere...';
            aiStats.textContent = 'Generiere...';
            
            const seed = Math.floor(Math.random() * 999999);
            
            console.log('AI: Generiere Bild f√ºr:', prompt, '| Model:', aiCurrentModel);
            
            try {
                // ComfyUI Generierung
                const img = await generateLocal(prompt, aiCurrentModel, seed);
                
                const generationTime = ((performance.now() - aiGenerationStart) / 1000).toFixed(1);
                aiLastGenerationTime = parseFloat(generationTime);
                
                // Geladenes Bild speichern f√ºr Canvas-Rendering
                aiLoadedImage = img;
                console.log('AI: aiLoadedImage gesetzt');
                
                // Bild anzeigen
                aiImage.src = img.src;
                aiImageStatus.textContent = `${generationTime}s`;
                
                // Wenn Modus 'off' ist, automatisch auf 'on' wechseln
                if (aiMode === 'off') {
                    aiMode = 'on';
                    document.querySelectorAll('.ai-mode-btn').forEach(b => b.classList.remove('active'));
                    document.querySelector('.ai-mode-btn[data-aimode="on"]').classList.add('active');
                }
                updateAiDisplay();
                
                // Preview im Panel
                aiImagePreview.innerHTML = `<img src="${img.src}" alt="AI Preview">`;
                aiStats.textContent = `Letzte: ${generationTime}s | ${new Date().toLocaleTimeString()}`;
                
                console.log('AI: Bild generiert in', generationTime, 's');
                
            } catch (error) {
                console.error('AI: Fehler bei Bildgenerierung:', error);
                aiStats.textContent = '‚ùå Fehler bei Generierung';
                aiImageStatus.textContent = 'Fehler';
            }
            
            aiIsGenerating = false;
            aiGenerateBtn.disabled = false;
            aiGenerateBtn.textContent = 'üé® Jetzt generieren';
        }
        
        // Auto-Generierung bei finalem Speech Result
        let aiLastAutoGeneratedInput = ''; // Verhindert doppelte Generierung
        
        function hookSpeechForAi() {
            // Observer f√ºr √Ñnderungen an window.aiLastSpeechInput
            let lastKnownInput = '';
            
            setInterval(() => {
                if (!aiAutoGenerate || aiMode === 'off') return;
                
                const text = window.aiLastSpeechInput || '';
                // Nur generieren wenn neuer Text und noch nicht generiert
                if (text && text !== lastKnownInput && text !== aiLastAutoGeneratedInput && text.length > 2) {
                    lastKnownInput = text;
                    aiLastAutoGeneratedInput = text;
                    
                    if (aiBufferMode) {
                        // Im Buffer-Modus: Local ComfyUI nutzen
                        const localTab = document.querySelector('.ai-provider-tab[data-provider="local"]');
                        if (localTab && localTab.classList.contains('has-key')) {
                            generateBufferImage(text, 0, 'local', 'local-sd15');
                        }
                    } else {
                        generateAiImage(text);
                    }
                }
                
                // Im Buffer-Modus: Kontinuierlich Buffer f√ºllen
                if (aiBufferMode) {
                    const currentText = window.aiLastSpeechInput || '';
                    if (currentText && currentText.length > 2) {
                        triggerContinuousGeneration(currentText);
                    }
                }
            }, 3000); // Alle 3 Sekunden pr√ºfen
        }
        
        // Hook nach kurzer Verz√∂gerung initialisieren
        setTimeout(hookSpeechForAi, 1000);

        // ============================================
        // ANIMATION LOOP
        // ============================================
        
        let lastNotes = [];
        let lastFrameTime = performance.now();
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Delta Time berechnen
            const now = performance.now();
            const deltaTime = (now - lastFrameTime) / 1000; // in Sekunden
            lastFrameTime = now;
            
            // MIDI hat Priorit√§t wenn aktiviert
            if (midiEnabled) {
                // MIDI-Updates passieren bereits im Event-Handler (handleMidiMessage)
                // Hier nur Level-Meter f√ºr Audio falls aktiv
                if (analyser) {
                    const timeData = new Float32Array(analyser.fftSize);
                    analyser.getFloatTimeDomainData(timeData);
                    let sum = 0;
                    for (let i = 0; i < timeData.length; i++) {
                        sum += timeData[i] * timeData[i];
                    }
                    const rms = Math.sqrt(sum / timeData.length);
                    const db = 20 * Math.log10(rms + 0.0001);
                    const percent = Math.max(0, Math.min(100, (db + 60) * 1.67));
                    levelMeter.style.width = percent + '%';
                    
                    // Gain-Level f√ºr Helligkeit speichern
                    if (gainLinked) {
                        currentGainLevel = percent / 100;
                        // Bei MIDI + Gain-Link: Farben kontinuierlich aktualisieren
                        const midiNotesList = getMidiNotes();
                        if (midiNotesList.length > 0) {
                            const analysis = analyzeIntervals(midiNotesList);
                            applyColors(analysis);
                        }
                    }
                } else if (gainLinked) {
                    currentGainLevel = 0;
                }
            } else if (pitchDetector) {
                // Audio Pitch Detection
                const notes = pitchDetector.detect();
                
                // Level Meter Update
                if (analyser) {
                    const timeData = new Float32Array(analyser.fftSize);
                    analyser.getFloatTimeDomainData(timeData);
                    let sum = 0;
                    for (let i = 0; i < timeData.length; i++) {
                        sum += timeData[i] * timeData[i];
                    }
                    const rms = Math.sqrt(sum / timeData.length);
                    const db = 20 * Math.log10(rms + 0.0001);
                    const percent = Math.max(0, Math.min(100, (db + 60) * 1.67));
                    levelMeter.style.width = percent + '%';
                    
                    // Gain-Level f√ºr Helligkeit speichern
                    if (gainLinked) {
                        currentGainLevel = percent / 100;
                    }
                } else if (gainLinked) {
                    currentGainLevel = 0; // Kein Audio = dunkel
                }
                
                const notesChanged = notes.length !== lastNotes.length || 
                    notes.some((n, i) => !lastNotes[i] || n.midi !== lastNotes[i].midi);
                
                if (notesChanged) {
                    lastNotes = notes;
                    const analysis = analyzeIntervals(notes);
                    updateUI(notes, analysis);
                    applyColors(analysis);
                } else if (gainLinked && lastAnalysis) {
                    // Bei Gain-Link: Gecachte Analyse wiederverwenden
                    applyColors(lastAnalysis);
                }
            } else if (gainLinked && lastAnalysis) {
                // Auch ohne Pitch-Detector bei Gain-Link updaten
                applyColors(lastAnalysis);
            }
            
            // Percussion Detection
            if (percussionEnabled && percussionDetector) {
                const percStates = percussionDetector.detect();
                updatePercussionUI(percStates);
            } else if (percussionEnabled && !percussionDetector && analyser && audioContext) {
                // Detector erstellen falls noch nicht vorhanden
                percussionDetector = new PercussionDetector(audioContext, analyser);
                console.log('PercussionDetector nachtr√§glich erstellt');
            }
            
            // Beat Detection
            if (analyser) {
                const beatDetected = detectBeat(analyser);
                if (beatDetected) {
                    triggerBeatFlash();
                    // Bei Beat-Sync: N√§chstes Bild anzeigen
                    if (aiBeatSync && aiBufferMode && aiImageBuffer.length > 0) {
                        displayNextBufferImage();
                    }
                }
            }
            
            // Beat Pulse abklingen lassen
            if (beatPulseAmount > 0) {
                beatPulseAmount *= 0.9; // Schnelles Abklingen
                if (beatPulseAmount < 0.01) beatPulseAmount = 0;
            }
            
            // Beat Rotation abklingen lassen (smooth decay)
            if (beatRotationAmount > 0) {
                beatRotationAmount *= 0.85; // Sanftes Abklingen
                if (beatRotationAmount < 0.001) beatRotationAmount = 0;
            }
            
            // Kamera Auto-Orbit
            updateAutoOrbit();
            
            // FOV Audio-Modulation
            updateFovWithAudio();
            
            // Partikel aktualisieren
            updateParticles(deltaTime, currentGainLevel);
            
            // Effekte anwenden/zur√ºcksetzen (nur wenn Modell sichtbar, also nicht bei Alex)
            // WICHTIG: Immer aufrufen, damit beim Deaktivieren von Effekten das Zur√ºcksetzen funktioniert!
            if (currentModel && activeSchema !== 'alex') {
                applyEffect(currentModel, deltaTime);
            }
            
            // === MODELL-SICHTBARKEIT ===
            // Kombination aus Schema (Alex = kein Modell) und manuellem Toggle
            const showModel = (activeSchema !== 'alex') && modelVisible;
            
            if (currentModel) {
                currentModel.visible = showModel;
            }
            if (morphOutgoingModel) {
                morphOutgoingModel.visible = showModel;
            }
            if (morphIncomingModel) {
                morphIncomingModel.visible = showModel;
            }
            
            // Nur rotieren und animieren wenn sichtbar
            if (showModel && currentModel && !morphingInProgress) {
                // Normale kontinuierliche Rotation + Beat-Rotation
                let rotationSpeed = baseRotationSpeed;
                if (beatRotationEnabled && beatRotationAmount > 0) {
                    rotationSpeed += beatRotationAmount; // Beat f√ºgt zus√§tzliche Rotation hinzu
                }
                currentModel.rotation.y += rotationSpeed;
                
                // Basis-Skalierung
                let finalScale = currentScale;
                
                // Audio-Skalierung anwenden
                if (audioScaleEnabled && currentGainLevel > 0) {
                    const audioScale = 1 + (currentGainLevel * audioScaleAmount);
                    finalScale *= audioScale;
                }
                
                // Beat Pulse auf Modell anwenden
                if (beatPulseEnabled && beatPulseAmount > 0) {
                    finalScale *= (1 + beatPulseAmount * 0.15);
                }
                
                currentModel.scale.set(finalScale, finalScale, finalScale);
            }
            // Rotiere auch w√§hrend des Morphings beide Modelle (nur wenn sichtbar)
            if (morphingInProgress) {
                updateMorphTransition();
                if (showModel) {
                    let rotationSpeed = baseRotationSpeed;
                    if (beatRotationEnabled && beatRotationAmount > 0) {
                        rotationSpeed += beatRotationAmount;
                    }
                    if (morphOutgoingModel) morphOutgoingModel.rotation.y += rotationSpeed;
                    if (morphIncomingModel) morphIncomingModel.rotation.y += rotationSpeed;
                }
            }
            
            controls.update();
            
            // Composer verwenden wenn irgendein Post-Processing aktiv, sonst direkt rendern
            const useComposer = edgePass.enabled || blurAmount > 0 || afterimagePass.enabled;
            if (useComposer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
            
            // === AI BILD AUF OVERLAY CANVAS ZEICHNEN (MIT CROSSFADE) ===
            aiOverlayCtx.clearRect(0, 0, aiOverlayCanvas.width, aiOverlayCanvas.height);
            
            // Crossfade Progress aktualisieren
            const crossfadeAlpha = updateCrossfade() || 1;
            
            if (aiMode !== 'off') {
                try {
                    const maxW = aiOverlayCanvas.width * 0.5;
                    const maxH = aiOverlayCanvas.height * 0.7;
                    
                    // Hilfsfunktion zum Zeichnen eines Bildes
                    const drawAiImage = (img, alpha) => {
                        if (!img || !img.complete || !img.naturalWidth) return;
                        
                        const imgW = img.naturalWidth;
                        const imgH = img.naturalHeight;
                        let destW = imgW;
                        let destH = imgH;
                        
                        if (destW > maxW) {
                            destH = (maxW / destW) * destH;
                            destW = maxW;
                        }
                        if (destH > maxH) {
                            destW = (maxH / destH) * destW;
                            destH = maxH;
                        }
                        
                        const destX = (aiOverlayCanvas.width - destW) / 2;
                        const destY = (aiOverlayCanvas.height - destH) / 2;
                        
                        aiOverlayCtx.save();
                        aiOverlayCtx.globalAlpha = alpha * (aiMode === 'overlay' ? 0.5 : 1);
                        aiOverlayCtx.drawImage(img, destX, destY, destW, destH);
                        aiOverlayCtx.restore();
                    };
                    
                    // Aktuelles Bild zeichnen (ausblendend w√§hrend Crossfade)
                    if (aiCurrentImage && aiNextImage) {
                        drawAiImage(aiCurrentImage, 1 - crossfadeAlpha);
                        drawAiImage(aiNextImage, crossfadeAlpha);
                    } else if (aiCurrentImage) {
                        drawAiImage(aiCurrentImage, 1);
                    } else if (aiLoadedImage) {
                        // Fallback f√ºr Nicht-Buffer-Modus
                        drawAiImage(aiLoadedImage, 1);
                    }
                    
                } catch (e) {
                    // CORS-Fehler ignorieren
                }
            }
        }
        
        animate();

        // ============================================
        // RESIZE
        // ============================================
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            // AI Overlay Canvas
            aiOverlayCanvas.width = window.innerWidth;
            aiOverlayCanvas.height = window.innerHeight;
            // Post-Processing Shader Resolutions aktualisieren
            edgePass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
            // Alle Blur-Passes aktualisieren
            blurPasses.forEach(pair => {
                pair.h.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
                pair.v.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
            });
            // Partikel-Shader
            if (particleSystem && particleSystem.material.uniforms) {
                particleSystem.material.uniforms.pointMultiplier.value = window.innerHeight / 2;
            }
        });
        
        // ============================================
        // FULLSCREEN TOGGLE
        // ============================================
        
        const fullscreenToggle = document.getElementById('fullscreenToggle');
        let isFullscreenMode = false;
        
        function toggleFullscreenMode() {
            isFullscreenMode = !isFullscreenMode;
            document.body.classList.toggle('fullscreen-mode', isFullscreenMode);
            fullscreenToggle.innerHTML = isFullscreenMode ? '‚úï' : '‚õ∂';
            fullscreenToggle.title = isFullscreenMode ? 'Men√ºs zeigen (F)' : 'Vollbild (F)';
        }
        
        fullscreenToggle.addEventListener('click', toggleFullscreenMode);
        
        // Keyboard shortcut: F f√ºr Fullscreen
        document.addEventListener('keydown', (e) => {
            if (e.key === 'f' || e.key === 'F') {
                // Nicht triggern wenn in Input-Feld
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
                toggleFullscreenMode();
            }
            // ESC um Fullscreen zu verlassen
            if (e.key === 'Escape' && isFullscreenMode) {
                toggleFullscreenMode();
            }
        });
        
        // Echter Browser-Fullscreen mit Doppelklick auf Canvas
        canvas.addEventListener('dblclick', () => {
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else {
                document.documentElement.requestFullscreen();
            }
        });
        
        // ============================================
        // STREAM F√úR OBS / MADMAPPER (Electron)
        // ============================================
        
        let streamEnabled = false;
        let streamFrameInterval = null;
        const streamStatusEl = document.getElementById('streamStatus');
        const STREAM_FPS = 30; // 30fps f√ºr stabilen Stream
        const STREAM_WIDTH = 1920;
        const STREAM_HEIGHT = 1080;
        
        // Separater Canvas f√ºr Stream-Output (immer 1920x1080)
        const streamCanvas = document.createElement('canvas');
        streamCanvas.width = STREAM_WIDTH;
        streamCanvas.height = STREAM_HEIGHT;
        const streamCtx = streamCanvas.getContext('2d');
        
        function captureStreamFrame() {
            // Berechne Skalierung um Canvas zu f√ºllen (cover/crop)
            const srcWidth = canvas.width;
            const srcHeight = canvas.height;
            const srcAspect = srcWidth / srcHeight;
            const dstAspect = STREAM_WIDTH / STREAM_HEIGHT;
            
            let sx, sy, sw, sh;
            
            if (srcAspect > dstAspect) {
                // Quelle ist breiter -> links/rechts croppen
                sh = srcHeight;
                sw = srcHeight * dstAspect;
                sx = (srcWidth - sw) / 2;
                sy = 0;
            } else {
                // Quelle ist h√∂her -> oben/unten croppen
                sw = srcWidth;
                sh = srcWidth / dstAspect;
                sx = 0;
                sy = (srcHeight - sh) / 2;
            }
            
            // Schwarzen Hintergrund (f√ºr den Fall dass was nicht passt)
            streamCtx.fillStyle = 'rgb(0,0,0)';
            streamCtx.fillRect(0, 0, STREAM_WIDTH, STREAM_HEIGHT);
            
            // Canvas auf Stream-Canvas zeichnen (gecroppt, nicht verzerrt)
            streamCtx.drawImage(
                canvas,
                sx, sy, sw, sh,           // Source (gecroppt)
                0, 0, STREAM_WIDTH, STREAM_HEIGHT  // Destination (1920x1080)
            );
            
            // === VIGNETTE F√úR STREAM ZEICHNEN ===
            if (currentVignetteColor) {
                const { r, g, b, a } = currentVignetteColor;
                const centerX = STREAM_WIDTH / 2;
                const centerY = STREAM_HEIGHT / 2;
                // Elliptisch wie CSS - gr√∂√üerer Radius
                const maxRadius = Math.max(STREAM_WIDTH, STREAM_HEIGHT) * 0.9;
                
                // Radialer Gradient mit vielen Stops f√ºr smooth Verlauf
                const gradient = streamCtx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, maxRadius
                );
                
                // Viele Gradient-Stops f√ºr weichen Verlauf (simuliert CSS radial-gradient)
                const rInt = Math.round(r * 255);
                const gInt = Math.round(g * 255);
                const bInt = Math.round(b * 255);
                
                // 30+ Stops f√ºr extra smooth gradient (finer vignette)
                const stops = [
                    [0.00, 1.00],
                    [0.03, 0.96],
                    [0.06, 0.91],
                    [0.09, 0.85],
                    [0.12, 0.78],
                    [0.15, 0.71],
                    [0.18, 0.64],
                    [0.21, 0.57],
                    [0.24, 0.50],
                    [0.27, 0.44],
                    [0.30, 0.38],
                    [0.33, 0.33],
                    [0.36, 0.28],
                    [0.39, 0.24],
                    [0.42, 0.20],
                    [0.45, 0.17],
                    [0.48, 0.14],
                    [0.51, 0.11],
                    [0.54, 0.09],
                    [0.57, 0.07],
                    [0.60, 0.055],
                    [0.63, 0.042],
                    [0.66, 0.031],
                    [0.69, 0.022],
                    [0.72, 0.015],
                    [0.75, 0.010],
                    [0.78, 0.006],
                    [0.81, 0.003],
                    [0.84, 0.001],
                    [0.88, 0.000],
                    [1.00, 0.000]
                ];
                
                stops.forEach(([pos, alpha]) => {
                    gradient.addColorStop(pos, `rgba(${rInt}, ${gInt}, ${bInt}, ${a * alpha})`);
                });
                
                streamCtx.fillStyle = gradient;
                streamCtx.fillRect(0, 0, STREAM_WIDTH, STREAM_HEIGHT);
            }
            
            // === AI BILD F√úR STREAM ZEICHNEN (MIT CROSSFADE) ===
            if (aiMode !== 'off') {
                try {
                    const destW = Math.min(512, STREAM_WIDTH * 0.4);
                    
                    const drawStreamAiImage = (img, alpha) => {
                        if (!img || !img.complete || !img.naturalWidth) return;
                        
                        const imgW = img.naturalWidth;
                        const imgH = img.naturalHeight;
                        const dH = (imgH / imgW) * destW;
                        const destX = (STREAM_WIDTH - destW) / 2;
                        const destY = (STREAM_HEIGHT - dH) / 2;
                        
                        streamCtx.save();
                        streamCtx.globalAlpha = alpha * (aiMode === 'overlay' ? 0.5 : 1);
                        if (aiMode === 'overlay') {
                            streamCtx.globalCompositeOperation = 'screen';
                        }
                        streamCtx.drawImage(img, destX, destY, destW, dH);
                        streamCtx.restore();
                    };
                    
                    // Crossfade im Stream
                    if (aiCurrentImage && aiNextImage && aiCrossfadeProgress < 1) {
                        drawStreamAiImage(aiCurrentImage, 1 - aiCrossfadeProgress);
                        drawStreamAiImage(aiNextImage, aiCrossfadeProgress);
                    } else if (aiCurrentImage) {
                        drawStreamAiImage(aiCurrentImage, 1);
                    } else if (aiLoadedImage) {
                        drawStreamAiImage(aiLoadedImage, 1);
                    }
                } catch (e) {
                    console.warn('AI Bild konnte nicht auf Stream Canvas gezeichnet werden:', e);
                }
            }
            
            return streamCanvas.toDataURL('image/jpeg', 0.85);
        }
        
        function startStreamCapture() {
            if (streamFrameInterval) return;
            
            const frameTime = 1000 / STREAM_FPS;
            
            streamFrameInterval = setInterval(() => {
                if (!streamEnabled || !window.electronAPI?.stream) return;
                
                const dataUrl = captureStreamFrame();
                window.electronAPI.stream.sendFrame(dataUrl);
            }, frameTime);
            
            console.log(`Stream Capture gestartet @ ${STREAM_FPS}fps, ${STREAM_WIDTH}x${STREAM_HEIGHT}`);
        }
        
        function stopStreamCapture() {
            if (streamFrameInterval) {
                clearInterval(streamFrameInterval);
                streamFrameInterval = null;
            }
            console.log('Stream Capture gestoppt');
        }
        
        // Electron Stream Events
        if (window.electronAPI?.stream) {
            // Status√§nderung vom Men√º
            window.electronAPI.stream.onStatusChange((data) => {
                streamEnabled = data.enabled;
                if (data.enabled) {
                    startStreamCapture();
                    streamStatusEl.classList.add('active');
                    streamStatusEl.textContent = `localhost:${data.port || 9876}`;
                } else {
                    stopStreamCapture();
                    streamStatusEl.classList.remove('active');
                }
            });
            
            // Initial Status abfragen
            window.electronAPI.stream.getStatus().then((status) => {
                console.log('Stream Status:', status);
                if (status.enabled) {
                    streamEnabled = true;
                    startStreamCapture();
                    streamStatusEl.classList.add('active');
                    streamStatusEl.textContent = `localhost:${status.port || 9876}`;
                }
            });
        }

    </script>
</body>
</html>